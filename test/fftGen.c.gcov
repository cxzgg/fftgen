        -:    0:Source:../fftGen.c
        -:    0:Graph:fftGen.gcno
        -:    0:Data:fftGen.gcda
        -:    0:Runs:35
        -:    1://##############################################################################
        -:    2:// File: fftGen.c
        -:    3://
        -:    4:// Version 1     2021 Jun 21st   jost.brachert@gmx.de
        -:    5://
        -:    6:// Generate C code to compute a Fast Fourier Transform (FFT) and an Inverse Fast
        -:    7:// Fourier Transform (IFFT).
        -:    8:// Target of the generated code is to compute the algorithms in a very fast way.
        -:    9:// This is achieved by
        -:   10:// a) unrolling the loops,
        -:   11:// b) removing operations where sequence elements are multiplied by sine or
        -:   12://    cosine function values being zero or one,
        -:   13:// c) optionally removing operations which are obsolete in certain
        -:   14://    circumstances, see documentation for details.
        -:   15:// Note that optimization a) is at the expense of code size.
        -:   16://
        -:   17://------------------------------------------------------------------------------
        -:   18:// Copyright (C) 2021  Jost Brachert, jost.brachert@gmx.de
        -:   19://
        -:   20:// This program is free software: you can redistribute it and/or modify it under
        -:   21:// the terms of the GNU General Public License as published by the Free Software
        -:   22:// Foundation; either version 3 of the license, or (at your option) any later
        -:   23:// version.
        -:   24://
        -:   25:// This program is distributed in the hope that it will be useful, but WITHOUT
        -:   26:// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
        -:   27:// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
        -:   28:// details.
        -:   29://
        -:   30:// You should have received a copy of the GNU General Public License along with
        -:   31:// this program, see file COPYING. If not, see https://www.gnu.org/licenses/.
        -:   32://
        -:   33:
        -:   34:/*!
        -:   35:\mainpage fftGen
        -:   36:
        -:   37:\section Name  NAME
        -:   38:
        -:   39:fftGen - Generate code to compute an FFT or IFFT
        -:   40:
        -:   41:
        -:   42:
        -:   43:\section Synopsis  SYNOPSIS
        -:   44:
        -:   45:\b fftGen [option]...
        -:   46:
        -:   47:\par Options:
        -:   48:[\c -n \e number] [\c \--points \e number]
        -:   49:[\c -i] [\c \--inverse]
        -:   50:[\c -r] [\c \--real-in-opt]
        -:   51:[\c -o] [\c \--real-out-opt]
        -:   52:[\c -m] [\c \--symm-in-opt]
        -:   53:[\c -s] [\c \--symm-out-opt]
        -:   54:[\c -l] [\c \--license]
        -:   55:[\c -v] [\c \--verbose]
        -:   56:[\c -V] [\c \--version]
        -:   57:[\c -h] [\c \--help]
        -:   58:
        -:   59:Note that it is \e required to specify the number of data points with options
        -:   60:\c -n or \c \--points.
        -:   61:
        -:   62:
        -:   63:
        -:   64:\section Description DESCRIPTION
        -:   65:
        -:   66:The program generates code to compute a Fast Fourier Transform (FFT) or Inverse
        -:   67:Fast Fourier Transform (IFFT) for the C or C++ programming language. Target of
        -:   68:the generated code is to compute the algorithms in a very fast way.
        -:   69:
        -:   70:The program needs to know the number of data points for the FFT. Either option
        -:   71:\c -n or \c \-\-points must therefore always be specified when the program is
        -:   72:called. The value of these options specifies the number of data points. It must
        -:   73:always be a power of two and it must not be zero. It may be equal one, however,
        -:   74:value one doesn't make much sense because in that case no code is produced.
        -:   75:
        -:   76:If the program shall compute an inverse FFT then option \c -i or \c \-\-inverse
        -:   77:must be given as argument. Note that in this case the result is scaled by
        -:   78:\c n if \c n is the number of data points. To get the correct result of an
        -:   79:inverse FFT the results of the generated code must be divided by \c n.
        -:   80:
        -:   81:The transform is conducted \"in place\", that means the resulting output
        -:   82:sequence overwrites the input sequence.
        -:   83:
        -:   84:
        -:   85:\subsection Optimizations Optimizations
        -:   86:
        -:   87:The speed of computation is achieved by a number of optimizations of the
        -:   88:standard Cooley-Tukey algorithm:
        -:   89:
        -:   90:1. Precomputing sine and cosine function values
        -:   91:
        -:   92:   During an FFT a lot of sine and cosine function values are to be computed.
        -:   93:   Computation of these function values is time-consuming. However, they are
        -:   94:   fixed and known for any FFT of a certain number of data points. It is thus
        -:   95:   possible to compute those function values once before conducting the actual
        -:   96:   transform - at best already at compile time.
        -:   97:
        -:   98:2. Unrolling loops
        -:   99:
        -:  100:   The FFT is usually computed in several loops. However, executing the loop
        -:  101:   control statements needs some time. That time can be saved if the loops are
        -:  102:   unrolled, that means, instead of jumping from the end of a loop to its
        -:  103:   beginning the statements of the loop are copied in series.
        -:  104:
        -:  105:   Drawback is certainly that the size of program increases.
        -:  106:
        -:  107:3. Inserting precomputed sine and cosine function values immediately into the
        -:  108:   algorithm
        -:  109:
        -:  110:   Both abovementioned optimizations offer this possibility. The precomputed
        -:  111:   function values can be inserted as literal constants directly into the source
        -:  112:   code of the unrolled loops. The access to those immediate constants is much
        -:  113:   faster than the indirect access to an array which would contain the
        -:  114:   precomputed values otherwise.
        -:  115:
        -:  116:   However, this comes also at the downside of increased code size.
        -:  117:
        -:  118:4. Removing multiplications by one
        -:  119:
        -:  120:5. Removing summands in expressions which are the result of a multiplication by
        -:  121:   zero
        -:  122:
        -:  123:6. Removing all operations assumed to be obsolete because the input sequence
        -:  124:   consists of real values only
        -:  125:
        -:  126:   This optimization is optional because it will produce wrong results if the
        -:  127:   input sequence contains non-zero imaginary values.
        -:  128:
        -:  129:   To activate this optimization use option \c -r.
        -:  130:
        -:  131:   If this option is specified then it is not necessary to initialize the array
        -:  132:   for imaginary values because these values are ignored.
        -:  133:
        -:  134:7. Removing all operations required to calculate points in the second half of
        -:  135:   the FFT result sequence
        -:  136:
        -:  137:   If the input sequence consists of real values only then the values of the
        -:  138:   resulting sequence are symmetrical to the value with index n/2 (indices
        -:  139:   starting at 0) if n is the number of data points - according to the following
        -:  140:   expression:
        -:  141:   \code
        -:  142:     x[i] = x*[n-i]     for i=n/2+1...n-1
        -:  143:   \endcode
        -:  144:   x*[n-i] denoting the conjugate complex value to x[n-i]. The conjugate complex
        -:  145:   value of complex variable z has the same real value and the negative
        -:  146:   imaginary value of z.
        -:  147:
        -:  148:   It is thus not necessary to calculate the points from n/2+1 on. They are
        -:  149:   usually not required and if needed they can anyway be calculated later in the
        -:  150:   way described above.
        -:  151:
        -:  152:   This optimization is optional because it will produce wrong results if the
        -:  153:   input sequence contains non-zero imaginary values.
        -:  154:
        -:  155:   To activate this optimization use option \c -s.
        -:  156:
        -:  157:   Note that if this option is specified then the points from n/2+1 onwards
        -:  158:   contain useless arbitrary values.
        -:  159:
        -:  160:8. Removing all operations assumed to be obsolete because the output sequence
        -:  161:   consists of real values only
        -:  162:
        -:  163:   This optimization is optional because it will produce wrong results if the
        -:  164:   input sequence will produce non-zero imaginary values in the result sequence.
        -:  165:
        -:  166:   To activate this optimization use option \c -o.
        -:  167:
        -:  168:   The output sequence contains real only values in case of an IFFT with an
        -:  169:   input sequence being the result of an FFT with real only input.
        -:  170:
        -:  171:   Note that a lot of manipulations of the result of the FFT that was used to
        -:  172:   generate the IFFT input sequence will spoil the property of generating real
        -:  173:   only output values in that IFFT. So use that option with care. It might be a
        -:  174:   good idea to first check the IFFT result before using this option.
        -:  175:
        -:  176:   Note that if this option is specified then the imaginary values in the result
        -:  177:   sequence contain useless arbitrary values.
        -:  178:
        -:  179:9. Removing all operations being obsolete because the input sequence is assumed
        -:  180:   to be symmetrical around the value with index n/2+1 (indices starting at 0)
        -:  181:   if n is the number of data points
        -:  182:
        -:  183:   For the exact assumed symmetry relationship see abovementioned
        -:  184:   optimization 7. A sequence gets that kind of symmetry if it is the result of
        -:  185:   an FFT (or IFFT) with real only input data points.
        -:  186:
        -:  187:   To activate this optimization use option \c -m.
        -:  188:
        -:  189:   If this option is specified then it is not necessary to initialize the arrays
        -:  190:   for real and imaginary values from the value with index n/2+1 onwards
        -:  191:   (indices starting at 0) because these values are ignored.
        -:  192:
        -:  193:
        -:  194:
        -:  195:\subsection Combinations Combinations of Optimizations
        -:  196:
        -:  197:Optimizations 6. and 7. (options \c -r and \c -s) are both for real only
        -:  198:input sequences for normal FFT and are therefore usually specified together.
        -:  199:
        -:  200:Optimizations 8. and 9. (options \c -o and \c -m) are both for symmetrical input
        -:  201:sequences for FFTs and IFFTs and are therefore usually specified together.
        -:  202:
        -:  203:Optimization 8. (option \c -o) is usually for inverse FFTs only. It thus does
        -:  204:not make much sense to combine it with options \c -r or \c -s.
        -:  205:
        -:  206:
        -:  207:
        -:  208:\section Size Size of the Generated Code
        -:  209:
        -:  210:Unrolling the loops increases the code size drastically. If \c m is the power of
        -:  211:two exponent to compute the number of data points of the FFT then the generated
        -:  212:lines of code for the FFT internal binary inversion algorithm can be computed by
        -:  213:\code
        -:  214:LOC_B = 2**(m/2) - 2**((m-1)/2) * 6
        -:  215:\endcode
        -:  216:\*\* means exponentiation
        -:  217:
        -:  218:The generated lines of code for the rest of the FFT transform can be calculated
        -:  219:by
        -:  220:\code
        -:  221:LOC_T = m*2**(m-1) * 6
        -:  222:\endcode
        -:  223:The total number of code lines for a certain number \c n of FFT data points is
        -:  224:\code
        -:  225:m   n       LOC_B   LOC_T   Total
        -:  226:3   8       12      72      84
        -:  227:4   16      36      192     228
        -:  228:5   32      72      480     552
        -:  229:6   64      168     1152    1320
        -:  230:7   128     336     2688    3024
        -:  231:8   256     720     6144    6844
        -:  232:9   512     1440    13824   15264
        -:  233:10  1024    2976    30720   33696
        -:  234:\endcode
        -:  235:Optimizations 6. to 9. will reduce the number of code lines a bit. For
        -:  236:<tt>m</tt>=5 (i.e. <tt>n</tt>=32) with optimizations 6. and 7. (options \c -r
        -:  237:and \c -s) the total number of code lines reduces to 365.
        -:  238:
        -:  239:
        -:  240:
        -:  241:\section Integration INTEGRATION
        -:  242:
        -:  243:The program generates the FFT code only, no function header and no function
        -:  244:ending. The generated code requires some defined variables:
        -:  245:- Two defined arrays for the complex sequence points, in particular
        -:  246:  - array <tt>xr[]</tt> for the real values and
        -:  247:  - array <tt>xi[]</tt>.
        -:  248:  .
        -:  249:  Both arrays must be of size \c n, where \c n is the number of data points of
        -:  250:  the FFT or IFFT.
        -:  251:- Two variables to store intermediate values:
        -:  252:  - <tt>tr</tt> and
        -:  253:  - <tt>ti</tt>.
        -:  254:
        -:  255:Advantage of this approach is that no assumption is required for the generated
        -:  256:code regarding the concrete type of the involved variables. The arrays and
        -:  257:variables can therefore be of any valid floating point type, e.g. \c double or
        -:  258:\c float.
        -:  259:
        -:  260:The generated code can easiest be integrated if it is piped to a file which is
        -:  261:then included via an \c \#include preprocessor statement into a function body
        -:  262:that provides the required definitions.
        -:  263:
        -:  264:\b Example:
        -:  265:
        -:  266:Assumed the generated code has been written to file \c fft.c and the FFT should
        -:  267:be computed in \c float arithmetic. Then the according code could look like
        -:  268:\code
        -:  269:void  fft (float *xr, float *xi) {
        -:  270:    float  tr, ti;
        -:  271:#include "fft.c"
        -:  272:}
        -:  273:\endcode
        -:  274:
        -:  275:Function <tt>fft()</tt> can now be called to compute the FFT. The calling
        -:  276:program must
        -:  277:- define the two arrays and
        -:  278:- fill them with the input values for the FFT,
        -:  279:- then call function <tt>fft()</tt> with the pointers to those arrays as
        -:  280:  arguments,
        -:  281:- take the resulting transformed values from the arrays.
        -:  282:- In case of an inverse FFT the results must be divided by \c n the number of
        -:  283:  the data points.
        -:  284:
        -:  285:
        -:  286:
        -:  287:\section Options  OPTIONS
        -:  288:
        -:  289:\par \c -n, \c \-\-points \e number
        -:  290:Number of data points of the FFT. The number must be a power of two.\n
        -:  291:This option is not optional. It must be given to specify the required number of
        -:  292:data points.
        -:  293:
        -:  294:\par \c -i, \c \-\-inverse
        -:  295:Generate code to calculate an inverse FFT.
        -:  296:
        -:  297:\par \c -r, \c \-\-real-in-opt
        -:  298:Optimize the code assuming that the imaginary input values are all zero, see
        -:  299:\ref Optimizations.
        -:  300:
        -:  301:\par \c -o, \c \-\-real-out-opt
        -:  302:Optimize the code assuming that in the result sequence all imaginary values are
        -:  303:zero. This is the case for an IFFT with an input sequence being the result of an
        -:  304:FFT with real only input. Use with care, see \ref Optimizations.
        -:  305:
        -:  306:\par \c -s, \c \-\-symm-out-opt
        -:  307:Optimize the code assuming that the FFT result is symmetrical to element n/2 if
        -:  308:n is the number of data points passed with option \c -n (indices starting at 0).
        -:  309:The result of the FFT is symmetrical around n/2 if the imaginary input values
        -:  310:are all zero. For details see \ref Optimizations.
        -:  311:
        -:  312:\par \c -m, \c \-\-symm-in-opt
        -:  313:Optimize the code assuming that the FFT input sequence is symmetrical to element
        -:  314:n/2 if n is the number of data points passed with option \c -n (indices starting
        -:  315:at 0), see \ref Optimizations.
        -:  316:
        -:  317:\par \c -l, \c \-\-license
        -:  318:Write a short GPL 3 license note at the beginning of the generated code.
        -:  319:
        -:  320:\par \c -v, \c \-\-verbose
        -:  321:Increase verbosity level, can be specified more than once. On level one writes
        -:  322:the chosen options to \c stderr.
        -:  323:
        -:  324:\par \c -V, \c \-\-version
        -:  325:Print version information and exit.
        -:  326:
        -:  327:\par \c -h, \c \-\-help
        -:  328:Print this info.
        -:  329:
        -:  330:
        -:  331:
        -:  332:\section ExitStatus  EXIT STATUS
        -:  333:
        -:  334:If no errors occurred in the course of the program the program terminates with
        -:  335:exit code \c 0. Otherwise it returns a system dependent error code different
        -:  336:from zero, see \c man \c stdlib.h -> \c EXIT_FAILURE.
        -:  337:
        -:  338:
        -:  339:
        -:  340:\section Diagnostics  DIAGNOSTICS
        -:  341:
        -:  342:Error messages are routed to \c stderr. They are sometimes accompanied by a
        -:  343:more detailed error description.
        -:  344:
        -:  345:\par \"Unknown argument\"
        -:  346:\par \"Unknown option\"
        -:  347:\par \"Invalid option argument\"
        -:  348:Wrong command line argument or option. See \ref Synopsis or \ref Options.
        -:  349:
        -:  350:\par \"Error allocating memory\"
        -:  351:Not enough heap memory available. It might help to close some applications.
        -:  352:
        -:  353:\par \"No number of points specified\"
        -:  354:The number of points must be specified using option \c -n. It must be a power of
        -:  355:two. See \ref Synopsis or \ref Options.
        -:  356:
        -:  357:\par \"Number of points is not a power of two\"
        -:  358:The number of data points specified with option \c -n must be a power of two.
        -:  359:See \ref Description or \ref Options.
        -:  360:
        -:  361:
        -:  362:
        -:  363:\section KnownBugs  KNOWN BUGS
        -:  364:
        -:  365:Not yet known. If you find one send an according note to the author.
        -:  366:
        -:  367:
        -:  368:
        -:  369:\section Author  AUTHOR
        -:  370:
        -:  371:jost.brachert@gmx.de
        -:  372:
        -:  373:
        -:  374:
        -:  375:\section Copyright  COPYRIGHT
        -:  376:
        -:  377:Copyright (C) 2021  Jost Brachert, jost.brachert@gmx.de
        -:  378:
        -:  379:This program is free software: you can redistribute it and/or modify it under
        -:  380:the terms of the GNU General Public License as published by the Free Software
        -:  381:Foundation; either version 3 of the license, or (at your option) any later
        -:  382:version.
        -:  383:
        -:  384:This program is distributed in the hope that it will be useful, but WITHOUT ANY
        -:  385:WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
        -:  386:PARTICULAR PURPOSE. See the GNU General Public License for more details.
        -:  387:
        -:  388:You should have received a copy of the GNU General Public License along with
        -:  389:this program, see file COPYING. If not, see https://www.gnu.org/licenses/.
        -:  390:
        -:  391:*/
        -:  392:
        -:  393:
        -:  394:
        -:  395:#include  <stdio.h>
        -:  396:#include   <math.h>     // sin(),cos(),fabs()
        -:  397:#include <string.h>     // strlen(),strcat(),strncpy(),strcmp(),strerror()
        -:  398:#include <stdlib.h>     // malloc(),exit(),free(),EXIT_SUCCESS,EXIT_FAILURE,NULL
        -:  399:#include  <errno.h>     // errno
        -:  400:
        -:  401:#define  LOGO       "fftGen"
        -:  402:#define  VERSION    "V1"
        -:  403:
        -:  404:#define  OPTIMIZE_SINE_COSINE_VALUES
        -:  405:
        -:  406://------------------------------------------------------------------------------
        -:  407:// Options for formatting of the generated source code
        -:  408:
        -:  409:#ifndef NUMBER_FORMAT
        -:  410:#define  NUMBER_FORMAT  "%21.14e"       // printf format for literal constants
        -:  411:#endif
        -:  412:#ifndef INDENT
        -:  413:#define  INDENT         ""              // Indentation of output code lines
        -:  414:#endif
        -:  415:
        -:  416:
        -:  417://------------------------------------------------------------------------------
        -:  418:// Definitions and Declarations
        -:  419:
        -:  420:static void  fftGen (int,int,int,int,int,int);  // Generating function
        -:  421:
        -:  422:
        -:  423:static char licenseText[] =
        -:  424:"// This program is free software: you can redistribute it and/or modify it under\n"
        -:  425:"// the terms of the GNU General Public License as published by the Free Software\n"
        -:  426:"// Foundation; either version 3 of the license, or (at your option) any later\n"
        -:  427:"// version.\n"
        -:  428:"//\n"
        -:  429:"// This program is distributed in the hope that it will be useful, but WITHOUT\n"
        -:  430:"// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"
        -:  431:"// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n"
        -:  432:"// details.\n"
        -:  433:"//\n"
        -:  434:"// You should have received a copy of the GNU General Public License along with\n"
        -:  435:"// this program, see file COPYING. If not, see https://www.gnu.org/licenses/.\n"
        -:  436:;
        -:  437:static char header[] = "";          // Starting code of the generated function
        -:  438:static char footer[] = "";          // Ending of the generated function
        -:  439:
        -:  440:
        -:  441://------------------------------------------------------------------------------
        -:  442:// Command line option descriptor
        -:  443:
        -:  444:typedef
        -:  445:    struct Option {
        -:  446:            char  *shOpt;       // Name of short option
        -:  447:            char  *lgOpt;       // Name of long option (w/ one "-" before)
        -:  448:            char  *fmt;         // scanf format spec to read the value
        -:  449:            void  *val;         // Pointer to dest. value of the option
        -:  450:        }
        -:  451:            OPTION;
        -:  452:
        -:  453:static int   checkOptions (int,const char*const*,int*,const OPTION*,int*);
        -:  454:static int   checkOption  (int,const char*const*,int*,const OPTION*);
        -:  455:static void  info (FILE*);
        -:  456:
        -:  457:
        -:  458:
        -:  459://==============================================================================
        -:  460:// main
        -:  461://
        -:  462:
       35:  463:int  main (
        -:  464:    const int    argc,
        -:  465:    const char  *argv[]
        -:  466:) {
        -:  467:    static int  n;       // Number of points for the FFT, must be a power of two
        -:  468:    static int  inv;     // Flag: !=0: Generate code for inverse FFT
        -:  469:    static int  realIn;  // Flag: !=0: Optimize for real only input
        -:  470:    static int  realOut; // Flag: !=0: Optimize for real only output
        -:  471:    static int  symmIn;  // Flag: !=0: Optimize for symmetry at input
        -:  472:    static int  symmOut; // Flag: !=0: Optimize for symmetry at output
        -:  473:    static int  verbose; // Level of verbosity
        -:  474:    static int  license; // Flag: !=0: Write a GPL 3 note at the beginning
        -:  475:#define  MAXOPT    50    // Must be greater than maximum length of short or
        -:  476:                         // long option strings (w/o parameter, including \0)
        -:  477:    static const OPTION  pOptions[] = {
        -:  478:        {"n", "-points"      , "%i", &n      },
        -:  479:        {"i", "-inverse"     , NULL, &inv    },
        -:  480:        {"r", "-real-in-opt" , NULL, &realIn },
        -:  481:        {"o", "-real-out-opt", NULL, &realOut},
        -:  482:        {"m", "-symm-in-opt" , NULL, &symmIn },
        -:  483:        {"s", "-symm-out-opt", NULL, &symmOut},
        -:  484:        {"l", "-license"     , NULL, &license},
        -:  485:        {"v", "-verbose"     , NULL, &verbose},
        -:  486:        {NULL, NULL          , NULL, NULL    }
        -:  487:    };
        -:  488:
        -:  489:    //==========================================================================
        -:  490:    // Handle command line arguments
        -:  491:    int  i;
       70:  492:    for (i=1; i<argc; i++) {
        -:  493:        // If a non-stand-alone '-'
       42:  494:        if (argv[i][0]=='-' && argv[i][1]) {
        -:  495:            // Advance past '-' to
        -:  496:            //  - either check a long option (pOp->lgOpt contains an additional
        -:  497:            //    '-' as first character),
        -:  498:            //  - or check a short option. The while loop then advances to
        -:  499:            //    further concatenated short options.
        -:  500:            // The while loop terminates
        -:  501:            //  - either in its first cycle if the command line option is a
        -:  502:            //    long option,
        -:  503:            //  - or if a short option with a parameter has been encountered.
       67:  504:            while (*++argv[i]) {
       65:  505:                int  o = 0;
       65:  506:                int  ret = checkOptions (argc,argv,&i,pOptions,&o);
       64:  507:                if (ret == 1) {
        -:  508:                    // It was a param.option, or a long option w/o parameter, so
        -:  509:                    // leave short option loop
       33:  510:                    break;
       31:  511:                } else if (ret == -1) {
        -:  512:                    // Boolean short option (w/o parameter)
        -:  513:                    // If short option is longer than one character:
       26:  514:                    int  j = 0;
       26:  515:                    while (pOptions[o].shOpt[++j]) {
    #####:  516:                        ++argv[i];          // Advance to next option in the
        -:  517:                    }                       // command line argument
        -:  518:                } else {
        -:  519:                    // ret==0: Option not found in the option list:
        -:  520:                    // Is it a "standard" option ?
        5:  521:                    if (    ! strcmp(argv[i],"-version")
        4:  522:                         || ! strncmp(argv[i],"V",1)) {
        2:  523:                        printf ("%s %s\n",LOGO,VERSION);
        2:  524:                        exit (EXIT_SUCCESS);
        3:  525:                    } else if (   ! strcmp(argv[i],"h")
        2:  526:                               || ! strcmp(argv[i],"-help")
        1:  527:                               || ! strncmp(argv[i],"?",1)) {
        2:  528:                        info (stdout);                  //  Print info and exit
        -:  529:                    }
        -:  530:                    // Option argument not found in option list
        -:  531:                    // Print error message, info, and terminate program
        1:  532:                    fprintf (stderr, "\n"LOGO": Unknown option -%s\n\n", argv[i]);
        1:  533:                    info (stderr);
        -:  534:                }
        -:  535:            }
        -:  536:        } else {
        -:  537:            // Print error message, info, and terminate program
        1:  538:            fprintf (stderr, "\n"LOGO": Unknown argument %s\n\n", argv[i]);
        1:  539:            info (stderr);
        -:  540:        }
        -:  541:    }
        -:  542:
       28:  543:    if (verbose > 0) {
        4:  544:        fprintf (stderr, "Number of points %d\n", n);
        4:  545:        if (inv) {
        1:  546:            fprintf (stderr,"Generating code for inverse FFT\n");
        -:  547:        } else {
        3:  548:            fprintf (stderr,"Generating code for standard (not inverse) FFT\n");
        -:  549:        }
        4:  550:        if (realIn) {
        1:  551:            fprintf (stderr,"Optimize for real only input\n");
        -:  552:        }
        4:  553:        if (realOut) {
        1:  554:            fprintf (stderr,"Optimize for real only output\n");
        -:  555:        }
        4:  556:        if (symmIn) {
        1:  557:            fprintf (stderr,"Optimize for symmetry at input\n");
        -:  558:        }
        4:  559:        if (symmOut) {
        1:  560:            fprintf (stderr,"Optimize for symmetry at output\n");
        -:  561:        }
        4:  562:        if (license) {
        1:  563:            fprintf (stderr,"Include a GPL 3 note into the code\n");
        -:  564:        }
        -:  565:    }
       28:  566:    if (n == 0) {
        1:  567:        fprintf (stderr,"\n"LOGO": No number of points specified.\n");
        1:  568:        info (stderr);
        -:  569:    }
       27:  570:    if (n & (n-1)) {    // Check n is not a power of two
        1:  571:        fprintf (stderr,"\n"LOGO": Number of points %d is not a power of two.\n", n);
        1:  572:        info (stderr);
        -:  573:    }
        -:  574:
       26:  575:    if (license)  fputs (licenseText, stdout);
       26:  576:    fputs (header, stdout);
        -:  577:
       26:  578:    fftGen (n,inv,realIn, realOut, symmIn, symmOut);
        -:  579:
       26:  580:    fputs (footer, stdout);
        -:  581:
       26:  582:    return  EXIT_SUCCESS;
        -:  583:}
        -:  584:
        -:  585:
        -:  586:
        -:  587://==============================================================================
        -:  588:// Code generating function
        -:  589://
        -:  590:
       26:  591:static void  fftGen (
        -:  592:    const int  n,             // Number of points
        -:  593:    const int  inv,           // Flag: !=0: inverse FFT
        -:  594:    const int  realIn,        // Flag: !=0: Optimize for real only input
        -:  595:    const int  realOut,       // Flag: !=0: Optimize for real only output
        -:  596:    const int  symmIn,        // Flag: !=0: Optimize for symmetry at input
        -:  597:    const int  symmOut        // Flag: !=0: Optimize for symmetry at output
        -:  598:) {
        -:  599:#define  LINELEN   200
        -:  600:    static char  line[LINELEN];
        -:  601:
        -:  602:    int     nm,mr,nn,m,k,istep,i,ii,jj;
        -:  603:    double  a,wr,wi;
        -:  604:
       26:  605:    const double  eps = 0.5*sin(M_PI/(n/2));
       26:  606:    const double  epsOne  =  1.0 - 0.5*(1.0-cos(M_PI/(n/2)));
       26:  607:    const double  epsMOne = -1.0 + 0.5*(1.0-cos(M_PI/(n/2)));
        -:  608:
       26:  609:    int  lastKCycle = 0;
        -:  610:
        -:  611:    typedef
        -:  612:        struct SwapSt {
        -:  613:            int  m;         // m and mr will have to be swapped
        -:  614:            int  mr;
        -:  615:            int  m_new;     // m value to be used for the source of the
        -:  616:                            // assignment insted of m at symmIn
        -:  617:            int  mr_new;    // mr value to be used for the source of the
        -:  618:                            // assignment insted of mr at symmIn
        -:  619:            int  symmIn;    // Flag: Use the input symmetry relationship for
        -:  620:                            // this element
        -:  621:        } SWAP;
        -:  622:    SWAP  *swap;
        -:  623:    int  nSwap;             // Number of swap commands in array swap[]
        -:  624:
        -:  625:    // To keep track of xi[i] being zero at realIn optimization.
        -:  626:    // If xi[i]!=0 then nz[i]==1.
       26:  627:    int  *nzi = (int*)malloc (sizeof(int)*n);
       26:  628:    if (nzi == NULL) {
    #####:  629:        fprintf (stderr, "\n"LOGO": Error allocating memory: %s\n", strerror(errno));
    #####:  630:        exit (EXIT_FAILURE);
        -:  631:    }
        -:  632:
       26:  633:    if ( ! realIn) {
     3251:  634:        for (i=0; i<n; ++i)  nzi[i] = 1;
        -:  635:    } else {
     1123:  636:        for (i=0; i<n; ++i)  nzi[i] = 0;
        -:  637:    }
        -:  638:
       26:  639:    nn = n-1;
        -:  640:
        -:  641:    //==========================================================================
        -:  642:    // Implement the binary inversion algorithm
        -:  643:
        -:  644:    // 1) Create the array swap[] to store the swapping commands to be conducted
        -:  645:    //    later.
        -:  646:    // 2) Fill it with the swapping commands of the binary inversion algorithm.
        -:  647:    // 3) In case of symmIn create new source indices mr_new according to the
        -:  648:    //    symmetry relationship x[m]=x*[mr_new=n-mr] (x* being the conjugate
        -:  649:    //    complex value) if mr > n/2.
        -:  650:    // 4) Check whether the new source index mr_new would have been overwritten
        -:  651:    //    already before the current swapping.
        -:  652:    //    - In that case insert the current swap command in the list before the
        -:  653:    //      one which would overwrite mr_new.
        -:  654:    // 5) Conduct the swapping commands in the order as now found in the array.
        -:  655:
       26:  656:    swap = (SWAP*)malloc (sizeof(SWAP)*n);
       26:  657:    if (swap == NULL) {
    #####:  658:        fprintf (stderr, "\n"LOGO": Error allocating memory: %s\n", strerror(errno));
    #####:  659:        exit (EXIT_FAILURE);
        -:  660:    }
     4374:  661:    for (i=0; i<n; ++i) {
     4348:  662:        swap[i].m = 0;
     4348:  663:        swap[i].mr = 0;
     4348:  664:        swap[i].m_new = 0;
     4348:  665:        swap[i].mr_new = 0;
        -:  666:    }
        -:  667:
        -:  668:    //--------------------------------------------------------------------------
        -:  669:    // Fill swap[] with the binary inversion swap commands and order the
        -:  670:    // elements such that if the symmetry relationship is to be used the source
        -:  671:    // elements are not overwritten
        -:  672:
       26:  673:    mr = 0;
     4348:  674:    for (nSwap=0,m=1; m<=nn; ++m) {
     4322:  675:        k = n;
        -:  676:        do {
     8502:  677:            k /= 2;
     8502:  678:        } while (mr+k > nn);
     4322:  679:        mr = mr%k + k;
        -:  680:
        -:  681:        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  682:        // Prepare implementation of "if (mr > m)  SWAP(x[m],x[mr]);"
        -:  683:
        -:  684:                    // nSwap is the index of the current swap command in swap[]
     4322:  685:        if (mr > m) {
     2026:  686:            if ( ! symmIn) {
     1234:  687:                swap[nSwap].m = m;             // Swapping according to standard
     1234:  688:                swap[nSwap].mr = mr;           //    binary inversion algorithm
     1234:  689:                swap[nSwap].symmIn = 0;
        -:  690:            } else {
        -:  691:                // Optimize assuming input symmetry
      792:  692:                swap[nSwap].m = m;
      792:  693:                swap[nSwap].mr = mr;
        -:  694:
      792:  695:                if (m<=n/2 && mr<=n/2) {
      191:  696:                    swap[nSwap].symmIn = 0;       // No symmetry subst. required
        -:  697:                } else {
      601:  698:                    int  i_m  = 0;
      601:  699:                    int  i_mr = 0;
      601:  700:                    int  m_new = m;
      601:  701:                    int  mr_new = mr;
        -:  702:
      601:  703:                    if (m  > n/2)  m_new  = n - m ; // Use symmetry relationship
      601:  704:                    if (mr > n/2)  mr_new = n - mr; //  "
        -:  705:
      601:  706:                    swap[nSwap].m_new = m_new;
      601:  707:                    swap[nSwap].mr_new = mr_new;
      601:  708:                    swap[nSwap].symmIn = 1;
        -:  709:
        -:  710:                    // Check whether the array element at the new mr (mr_new)
        -:  711:                    // would have been assigned already
        -:  712:
      601:  713:                    if (m > n/2) {
        -:  714:                        // Check whether m_new would have been overwritten by a
        -:  715:                        // writing to element with index m or mr
    16741:  716:                        for (i_m=nSwap-1; i_m>0; --i_m) {
    16741:  717:                            if (m_new == swap[i_m].m || m_new == swap[i_m].mr)  break;
        -:  718:                        }
        -:  719:                    }
      601:  720:                    if (mr > n/2) {
        -:  721:                        // Check whether mr_new would have been overwritten by a
        -:  722:                        // writing to element with index m or mr
    78723:  723:                        for (i_mr=nSwap-1; i_mr>0; --i_mr) {
    78580:  724:                            if (mr_new == swap[i_mr].m || mr_new == swap[i_mr].mr)  break;
        -:  725:                        }
        -:  726:                    }
        -:  727:
        -:  728:                    // Use the lowest of both and assign it to i_mr
      601:  729:                    if (i_mr>0 && i_m>0) {
      188:  730:                        if (i_mr>i_m)  i_mr = i_m;
      413:  731:                    } else if (i_m>0) {
    #####:  732:                        i_mr = i_m;
        -:  733:                    }
        -:  734:
        -:  735:                    // If the search ended successfully (i.e. before reaching 0)
      601:  736:                    if (i_mr > 0) {
        -:  737:                        // The array element at mr_new would have been assigned
        -:  738:                        // already.
        -:  739:                        // Create space in array swap[] at index i_mr, firstly
        -:  740:                        // overwriting swap[nSwap]
    62292:  741:                        for (ii=nSwap; ii>i_mr; --ii) {
    61834:  742:                            swap[ii].m      = swap[ii-1].m ;
    61834:  743:                            swap[ii].mr     = swap[ii-1].mr;
    61834:  744:                            swap[ii].m_new  = swap[ii-1].m_new;
    61834:  745:                            swap[ii].mr_new = swap[ii-1].mr_new;
    61834:  746:                            swap[ii].symmIn = swap[ii-1].symmIn;
        -:  747:                        }
        -:  748:                        // Insert the new swap command at index ii, i.e.
        -:  749:                        // before the command that would overwrite mr
      458:  750:                        swap[i_mr].m = m;
      458:  751:                        swap[i_mr].mr = mr;
      458:  752:                        swap[i_mr].m_new = m_new;
      458:  753:                        swap[i_mr].mr_new = mr_new;
      458:  754:                        swap[i_mr].symmIn = 1;
        -:  755:                    }
        -:  756:                }
        -:  757:            }
     2026:  758:            ++nSwap;
        -:  759:        }
        -:  760:    }
       26:  761:    if (symmIn) {
        -:  762:        // When optimizing assuming input symmetry then
        -:  763:        //   check whether there are indices not yet considered.
        -:  764:        // Therefore, check swap[] for not listed indices from n/2+1 onwards.
        -:  765:        // Consider the symmetry relationship for those now.
        -:  766:        // Note: This must be done before conducting the binary inversion
        -:  767:        // algorithm because that will overwrite the elements with according
        -:  768:        // indices.
      832:  769:        for (i=n/2+1; i<n; ++i) {
   181820:  770:            for (ii=nSwap-1; ii>=0; --ii) {
   181780:  771:                if (swap[ii].m==i || swap[ii].mr==i)  break;
        -:  772:            }
      829:  773:            if (ii < 0) {   // i not listed in swap[]
       40:  774:                printf (INDENT"xr[%d] =  xr[%d];\n", i, n - i);
       40:  775:                printf (INDENT"xi[%d] = -xi[%d];\n", i, n - i);
        -:  776:            }
        -:  777:        }
        -:  778:    }
        -:  779:
        -:  780:    //--------------------------------------------------------------------------
        -:  781:    // Conduct swapping
        -:  782:
     2052:  783:    for (k=0; k<nSwap; ++k) {
        -:  784:        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  785:        // Implement  "if (mr > m)  SWAP(x[m],x[mr]);"
     2026:  786:        if ( ! swap[k].symmIn) {
        -:  787:            // Swapping according to standard binary inversion algorithm
     1425:  788:            printf (INDENT"tr = xr[%d];\n", swap[k].m);
     1425:  789:            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].m, swap[k].mr);
     1425:  790:            printf (INDENT"xr[%d] = tr;\n", swap[k].mr);
     1425:  791:            if ( ! realIn) {
      889:  792:                printf (INDENT"ti = xi[%d];\n", swap[k].m);
      889:  793:                printf (INDENT"xi[%d] = xi[%d];\n", swap[k].m, swap[k].mr);
      889:  794:                printf (INDENT"xi[%d] = ti;\n", swap[k].mr);
        -:  795:            }
        -:  796:        } else {
        -:  797:            // Use the conjugate complex value of (xr[n-mr],xi[n-mr]) but only
        -:  798:            // if the source index of the assignment would have been >n/2
      601:  799:            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].mr, swap[k].m_new);
      601:  800:            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].m, swap[k].mr_new);
      601:  801:            if ( ! realIn) {
      601:  802:                if (swap[k].m <= n/2) {
      413:  803:                    printf (INDENT"xi[%d] = xi[%d];\n", swap[k].mr, swap[k].m_new);
        -:  804:                } else {
        -:  805:                    // Negating xi for the conjugate complex value is required
      188:  806:                    printf (INDENT"xi[%d] = -xi[%d];\n", swap[k].mr, swap[k].m_new);
        -:  807:                }
      601:  808:                if (swap[k].mr <= n/2) {
    #####:  809:                    printf (INDENT"xi[%d] = xi[%d];\n", swap[k].m, swap[k].mr_new);
        -:  810:                } else {
        -:  811:                    // Negating xi for the conjugate complex value is required
      601:  812:                    printf (INDENT"xi[%d] = -xi[%d];\n", swap[k].m, swap[k].mr_new);
        -:  813:                }
        -:  814:            }
        -:  815:        }
        -:  816:    }
       26:  817:    putchar ('\n');
        -:  818:
        -:  819:    //==========================================================================
        -:  820:    // Do the transform
        -:  821:
      168:  822:    for (k=1; k<n; k=istep) {
      142:  823:        istep = 2*k;
      142:  824:        if (istep==n)  lastKCycle = 1;
        -:  825:
     4464:  826:        for (m=0; m<k; ++m) {
     4322:  827:            a  = M_PI*(-m)/k;
     4322:  828:            wr = cos (a);
     4322:  829:            wi = sin (a);
     4322:  830:            if (inv)  wi = -wi;     // Prepare inverse FFT
     4322:  831:            ii = m;
     4322:  832:            nm = (nn-m)/istep + m;
    23460:  833:            for (i=m; i<=nm; ++i) {
        -:  834:                size_t  len;
        -:  835:                               // Flag: 1st summand of
        -:  836:                               //   tr = wr*xr[jj] - wi*xi[jj];
        -:  837:                               // or
        -:  838:                               //   ti = wr*xi[jj] + wi*xr[jj];
        -:  839:                               // is zero
        -:  840:                int  firstOpZero;
    19138:  841:                int  trz = 0;  // Flag: Expression tr=wr*xr[jj]-wi*xi[jj] == 0
    19138:  842:                int  tiz = 0;  // Flag: Expression ti=wr*xi[jj]+wi*xr[jj] == 0
        -:  843:
    19138:  844:                jj = ii+k;
        -:  845:
        -:  846:#ifndef OPTIMIZE_SINE_COSINE_VALUES
        -:  847:                printf (INDENT"tr = "NUMBER_FORMAT"*xr[%d] - "NUMBER_FORMAT"*xi[%d];\n", wr, jj, wi, jj);
        -:  848:                printf (INDENT"ti = "NUMBER_FORMAT"*xi[%d] + "NUMBER_FORMAT"*xr[%d];\n", wr, jj, wi, jj);
        -:  849:#else
        -:  850:                //--------------------------------------------------------------
        -:  851:                // Implement tr = wr*xr[jj] - wi*xi[jj];
        -:  852:
        -:  853:                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  854:                // Part wr*xr[jj]
    19138:  855:                firstOpZero = 0;
        -:  856:
    19138:  857:                snprintf (line, LINELEN, INDENT"tr =");
    19138:  858:                len = strlen (line);
        -:  859:
    19138:  860:                if (fabs(wr) > eps) {
        -:  861:                    // wr != 0
    16990:  862:                    if (wr < epsOne) {
        -:  863:                        // wr != 1
    12668:  864:                        if (wr > epsMOne) {
        -:  865:                            // wr != -1
    12668:  866:                            snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xr[%d]", wr, jj);
        -:  867:                        } else {
        -:  868:                            // wr == -1
    #####:  869:                            snprintf (line+len,LINELEN-len," -xr[%d]", jj);
        -:  870:                        }
        -:  871:                    } else {
        -:  872:                        // wr == 1
     4322:  873:                        snprintf (line+len,LINELEN-len," xr[%d]", jj);
        -:  874:                    }
        -:  875:                } else {
     2148:  876:                    firstOpZero = 1;
        -:  877:                }
    19138:  878:                len = strlen (line);
        -:  879:
        -:  880:                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  881:                // Part -wi*xi[jj]
        -:  882:
    19138:  883:                trz = 0;
    19138:  884:                if (fabs(wi) > eps  &&  nzi[jj]) {
        -:  885:                    // wi != 0  and  xi[jj] non-zero
    14259:  886:                    if (wi < epsOne) {
        -:  887:                        // wi != 1
    13185:  888:                        if (wi > epsMOne) {
        -:  889:                            // wi != -1
    12668:  890:                            if ( ! firstOpZero) {       // If wr*xr[jj] != 0
    12668:  891:                                if (wi >= 0.0) {
     6334:  892:                                    snprintf (line+len,LINELEN-len," - "NUMBER_FORMAT"*xi[%d]", wi, jj);
        -:  893:                                } else {
     6334:  894:                                    snprintf (line+len,LINELEN-len," + "NUMBER_FORMAT"*xi[%d]", -wi, jj);
        -:  895:                                }
        -:  896:                            } else {
    #####:  897:                                snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xi[%d]", -wi, jj);
        -:  898:                            }
        -:  899:                        } else {
        -:  900:                            // wi == -1
      517:  901:                            if ( ! firstOpZero) {
    #####:  902:                                snprintf (line+len,LINELEN-len," + xi[%d]", jj);
        -:  903:                            } else {
      517:  904:                                snprintf (line+len,LINELEN-len," xi[%d]", jj);
        -:  905:                            }
        -:  906:                        }
        -:  907:                    } else {
        -:  908:                        // wi == 1
     1074:  909:                        snprintf (line+len,LINELEN-len," - xi[%d]", jj);
        -:  910:                    }
    14259:  911:                    fputs (line, stdout);
    14259:  912:                    fputs (";\n", stdout);
        -:  913:                } else {
        -:  914:                    // wr == 0  or  xi[jj] == 0
     4879:  915:                    if ( ! firstOpZero) {
     4322:  916:                        fputs (line, stdout);
     4322:  917:                        fputs (";\n", stdout);
        -:  918:                    } else {
      557:  919:                        trz = 1;    // tr = wr*xr[jj]-wi*xi[jj] == 0
        -:  920:                        // Expression for tr is zero, so don't write anything
        -:  921:                    }
        -:  922:                }
        -:  923:
        -:  924:                //--------------------------------------------------------------
        -:  925:                // Implement ti = wr*xi[jj] + wi*xr[jj];
        -:  926:
    19138:  927:                if ( ! (realOut && lastKCycle)) {
        -:  928:
        -:  929:                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  930:                    // Part wr*xi[jj]
        -:  931:
    18242:  932:                    firstOpZero = 0;
    18242:  933:                    snprintf (line, LINELEN, INDENT"ti =");
    18242:  934:                    len = strlen (line);
        -:  935:
    18242:  936:                    if (fabs(wr) > eps  &&  nzi[jj]) {
        -:  937:                        // wr != 0  and  xi[jj] non-zero
    14980:  938:                        if (wr < epsOne) {
        -:  939:                            // wr != 1
    11778:  940:                            if (wr > epsMOne) {
        -:  941:                                // wr != -1
    11778:  942:                                snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xi[%d]", wr, jj);
        -:  943:                            } else {
        -:  944:                                // wr == -1
    #####:  945:                                snprintf (line+len,LINELEN-len," -xi[%d]", jj);
        -:  946:                            }
        -:  947:                        } else {
        -:  948:                            // wr == 1
     3202:  949:                            snprintf (line+len,LINELEN-len," xi[%d]", jj);
        -:  950:                        }
        -:  951:                    } else {
     3262:  952:                        firstOpZero = 1;
        -:  953:                    }
    18242:  954:                    len = strlen (line);
        -:  955:
        -:  956:                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -:  957:                    // Part +wi*xr[jj]
        -:  958:
    18242:  959:                    tiz = 0;
    18242:  960:                    if (fabs(wi) > eps) {
        -:  961:                        // wi != 0
    13923:  962:                        if (wi < epsOne) {
        -:  963:                            // wi != 1
    12852:  964:                            if (wi > epsMOne) {
        -:  965:                                // wi != -1
    11778:  966:                                if ( ! firstOpZero) {       // If wr*xr[jj] != 0
    11778:  967:                                    if (wi >= 0.0) {
     5444:  968:                                        snprintf (line+len,LINELEN-len," + "NUMBER_FORMAT"*xr[%d]", wi, jj);
        -:  969:                                    } else {
     6334:  970:                                        snprintf (line+len,LINELEN-len," - "NUMBER_FORMAT"*xr[%d]", -wi, jj);
        -:  971:                                    }
        -:  972:                                } else {
    #####:  973:                                    snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xr[%d]", wi, jj);
        -:  974:                                }
        -:  975:                            } else {
        -:  976:                                // wi == -1
     1074:  977:                                snprintf (line+len,LINELEN-len," - xr[%d]", jj);
        -:  978:                            }
        -:  979:                        } else {
        -:  980:                            // wi == 1
     1071:  981:                            snprintf (line+len,LINELEN-len," xr[%d]", jj);
        -:  982:                        }
    13923:  983:                        fputs (line, stdout);
    13923:  984:                        fputs (";\n", stdout);
        -:  985:                    } else {
        -:  986:                        // wi == 0
     4319:  987:                        if ( ! firstOpZero) {      // If wr*xi[jj] != 0
     3202:  988:                            fputs (line, stdout);
     3202:  989:                            fputs (";\n", stdout);
        -:  990:                        } else {
     1117:  991:                            tiz = 1;    // ti = wr*xi[jj]+wi*xr[jj] == 0
        -:  992:                            // Expression for tr is zero, so don't write anything
        -:  993:                        }
        -:  994:                    }
        -:  995:                }
        -:  996:#endif
    19138:  997:                if ( ! (symmOut && lastKCycle && jj!=n/2)) {
        -:  998:                    //----------------------------------------------------------
        -:  999:                    // Implement xr[jj] = xr[ii] - tr;
        -: 1000:
    18565: 1001:                    if ( ! trz) {
    18010: 1002:                        printf (INDENT"xr[%d] = xr[%d] - tr;\n", jj, ii);
        -: 1003:                    } else {
      555: 1004:                        printf (INDENT"xr[%d] = xr[%d];\n", jj, ii);
        -: 1005:                    }
        -: 1006:
        -: 1007:                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -: 1008:                    // Implement xi[jj] = xi[ii] - ti;
        -: 1009:
    18565: 1010:                    if ( ! (realOut && lastKCycle)) {
    17669: 1011:                        if ( ! tiz) {
    16552: 1012:                            if (nzi[ii]) {
    15997: 1013:                                printf (INDENT"xi[%d] = xi[%d] - ti;\n", jj, ii);
        -: 1014:                            } else {
      555: 1015:                                printf (INDENT"xi[%d] = - ti;\n", jj);
        -: 1016:                            }
    16552: 1017:                            nzi[jj] = 1;
        -: 1018:                        } else {
     1117: 1019:                            if (nzi[ii]) {
    #####: 1020:                                printf (INDENT"xi[%d] = xi[%d];\n", jj, ii);
    #####: 1021:                                nzi[jj] = 1;
     1117: 1022:                            } else if (realIn && lastKCycle) {
        -: 1023:                                // In case of realIn this element has not yet
        -: 1024:                                // been touched. So it must be set zero here
        -: 1025:                                // because imaginary input values at realIn
        -: 1026:                                // could be arbitrary but should contain valid
        -: 1027:                                // values at output
        3: 1028:                                printf (INDENT"xi[%d] = 0.0;\n", jj);
        -: 1029:                            }
        -: 1030:                        }
        -: 1031:                    }
        -: 1032:                }
        -: 1033:
        -: 1034:                //--------------------------------------------------------------
        -: 1035:                // Implement xr[ii] += tr;
        -: 1036:
    19138: 1037:                if ( ! trz) {
    18581: 1038:                    printf (INDENT"xr[%d] += tr;\n", ii);
        -: 1039:                }
        -: 1040:
        -: 1041:                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        -: 1042:                // Implement xi[ii] += ti;
        -: 1043:
    19138: 1044:                if ( ! (realOut && lastKCycle)) {
    18242: 1045:                    if ( ! tiz) {
    17125: 1046:                        if (nzi[ii]) {
    16568: 1047:                            printf (INDENT"xi[%d] += ti;\n", ii);
        -: 1048:                        } else {
      557: 1049:                            printf (INDENT"xi[%d] = ti;\n", ii);
      557: 1050:                            nzi[ii] = 1;
        -: 1051:                        }
     1117: 1052:                    } else if (realIn && lastKCycle) {
        -: 1053:                        // In case of realIn this element has not yet been
        -: 1054:                        // touched. So it must be set zero here because
        -: 1055:                        // imaginary input values at realIn could be arbitrary
        -: 1056:                        // but should contain valid values at output
        3: 1057:                        printf (INDENT"xi[%d] = 0.0;\n", ii);
        -: 1058:                    }
        -: 1059:                }
        -: 1060:
    19138: 1061:                ii += istep;
        -: 1062:            }
        -: 1063:        }
        -: 1064:    }
        -: 1065:
       26: 1066:    free (swap);
       26: 1067:    free (nzi);
       26: 1068:}
        -: 1069:
        -: 1070:
        -: 1071:
        -: 1072://==============================================================================
        -: 1073:// checkOptions  V1.2
        -: 1074://
        -: 1075:// Checks whether the command line option passed via argv[*pi] can be found in
        -: 1076:// the option array passed as *pOp.
        -: 1077:// The last entry of the option array must consist of zeroes to mark the end of
        -: 1078:// the array.
        -: 1079://
        -: 1080:// If the option passed as argv[*pi] is found in the array the according array
        -: 1081:// index is returned in *po.
        -: 1082:// In that case the function returns 1 as return value if the option was a long
        -: 1083:// option with or without a parameter or -1 if the option was a short option
        -: 1084:// without a parameter.
        -: 1085://
        -: 1086:// If the passed option could not be fond in the option array then the function
        -: 1087:// returns zero as return value.
        -: 1088://
        -: 1089:
       65: 1090:static int  checkOptions (
        -: 1091:    const int           argc,    // No. of command line entries (from main())
        -: 1092:    const char *const   argv[],  // Command line entries  (from main())
        -: 1093:          int  *const   pi,      // Ptr to current command line entry index
        -: 1094:    const OPTION       *pOp,     // Ptr to option array
        -: 1095:          int  *const   po       // Index into option array
        -: 1096:) {
       65: 1097:    int  ret = 0;
        -: 1098:
      207: 1099:    for (*po=0; pOp->shOpt; ++pOp,++*po) {
      202: 1100:        ret = checkOption (argc,argv,pi,pOp);
      201: 1101:        if (ret != 0)  return ret;
        -: 1102:    }
        5: 1103:    return ret;
        -: 1104:}
        -: 1105:
        -: 1106:
        -: 1107:
        -: 1108://==============================================================================
        -: 1109:// checkOption  V1.2
        -: 1110://
        -: 1111:// Routine checks whether option passed via argv[*pi] fits to the option in
        -: 1112:// option list pointed to by pOp.
        -: 1113://
        -: 1114:// If the currently checked option *pOp fits to the currently examined command
        -: 1115:// line argument argv[*pi] and if it is an option with a parameter store the
        -: 1116:// value in the option structure and return 1.
        -: 1117://
        -: 1118:// If the currently checked option *pOp fits to the currently examined command
        -: 1119:// line argument argv[*pi] and if it is an option without a parameter increment
        -: 1120:// the option value in the option structure by one and return 0.
        -: 1121://
        -: 1122:// If the currently checked option *pOp doesn't fit to the currently examined
        -: 1123:// command line argument argv[*pi] return 0.
        -: 1124:
      202: 1125:static int  checkOption (
        -: 1126:    const int           argc,    // No. of command line entries (from main())
        -: 1127:    const char   *const argv[],  // Command line entries  (from main())
        -: 1128:          int    *const pi,      // Ptr to current command line entry index
        -: 1129:    const OPTION *const pOp      // Ptr to current option from option list
        -: 1130:) {
     202*: 1131:    if (pOp->fmt && pOp->fmt[1] == 's') {
        -: 1132:        // Test whether one of the different possibilities for this option
        -: 1133:        // fits to the just read command line option.
        -: 1134:        // Check at first whether the first characters are equal to the short
        -: 1135:        // or long option name.
        -: 1136:
        -: 1137:        int  len;
        -: 1138:
    #####: 1139:        if (    ( len=strlen(pOp->shOpt), ! strncmp(argv[*pi],pOp->shOpt,len) )
    #####: 1140:             || ( len=strlen(pOp->lgOpt), ! strncmp(argv[*pi],pOp->lgOpt,len) )
        -: 1141:           ) {
        -: 1142:            // It is this short or long option: Now, is it of kind
        -: 1143:            // "-Opt=XY" or "-OptXY" or "-Opt XY" (in that order)
        -: 1144:
    #####: 1145:            switch (argv[*pi][len]) {
    #####: 1146:                case '\0': if (++*pi==argc) {
    #####: 1147:                               fprintf (stderr, "\n"LOGO": Missing option argument\n");
    #####: 1148:                               info (stderr);
        -: 1149:                           }
    #####: 1150:                           *(const char**)pOp->val = argv[*pi];
    #####: 1151:                           break;
        -: 1152:
    #####: 1153:                case '=' : ++len;
    #####: 1154:                           *(const char**)pOp->val = argv[*pi] + len;
    #####: 1155:                           break;
        -: 1156:
    #####: 1157:                default  : *(const char**)pOp->val = argv[*pi] + len;
    #####: 1158:                           break;
        -: 1159:            }
    #####: 1160:            return 1;           // Signal: option found and parameter read
        -: 1161:        }
        -: 1162:    } else {
        -: 1163:        char  fmtStr[MAXOPT+5];
        -: 1164:
        -: 1165:        // Test whether one of the different possibilities for this option
        -: 1166:        // fits to the just read command line option.
        -: 1167:        // If the short option were "shOpt" and the long option were "loOpt"
        -: 1168:        // and the option value were 10 then the possibilities checked here
        -: 1169:        // would be "-shOpt10", "--loOpt10", "-shOpt=10" and "--loOpt=10".
        -: 1170:
      202: 1171:        if (    pOp->fmt
       65: 1172:             && (   // Assemble sscanf format string to e.g. "shopt=%f" etc.
       65: 1173:                    sscanf( argv[*pi], strcat(strcat(strncpy(fmtStr,pOp->shOpt,MAXOPT),"="),pOp->fmt), pOp->val )==1
       62: 1174:                 || sscanf( argv[*pi], strcat(       strncpy(fmtStr,pOp->shOpt,MAXOPT)     ,pOp->fmt), pOp->val )==1
       40: 1175:                 || sscanf( argv[*pi], strcat(strcat(strncpy(fmtStr,pOp->lgOpt,MAXOPT),"="),pOp->fmt), pOp->val )==1
       40: 1176:                 || sscanf( argv[*pi], strcat(       strncpy(fmtStr,pOp->lgOpt,MAXOPT)     ,pOp->fmt), pOp->val )==1
        -: 1177:                )
        -: 1178:           ) {
        -: 1179:
       59: 1180:            return 1;           // Signal: option found and parameter read
        -: 1181:
        -: 1182:        }
        -: 1183:        // Check short option without parameter
      177: 1184:        else if ( ! strncmp(argv[*pi],pOp->shOpt,strlen(pOp->shOpt)) && ! pOp->fmt) {
        -: 1185:            // Command line argument is a short option without parameter
        -: 1186:
       26: 1187:            ++*(int*)pOp->val;  // Set TRUE, or count up if used more than once
        -: 1188:
       26: 1189:            return -1;          // Signal: boolean short option found
        -: 1190:
        -: 1191:        }
        -: 1192:        // Check short option with parameter or
        -: 1193:        // long option with or without parameter
      151: 1194:        else if (    ! strcmp(argv[*pi],pOp->shOpt)
      149: 1195:                  || ! strcmp(argv[*pi],pOp->lgOpt)) {
        -: 1196:
        -: 1197:            // Check whether the option is without parameter
        9: 1198:            if ( ! pOp->fmt) {
        -: 1199:                // Command line argument is a long option without parameter
        -: 1200:                // (short option has already checked above)
        6: 1201:                ++*(int*)pOp->val;  // Set TRUE, or count up if used more than once
        -: 1202:
        6: 1203:                return 1;           // Signal: boolean long option found
        -: 1204:
        -: 1205:            // We found a "-shOpt" or "--loOpt". Now we look for the number:
        3: 1206:            } else if (++*pi==argc || sscanf(argv[*pi],pOp->fmt,pOp->val)!=1) {
        1: 1207:                fprintf (stderr, "\n"LOGO": Invalid option argument %s\n\n", argv[*pi]);
        1: 1208:                info (stderr);      // No number with the correct format found !
        -: 1209:            } else {
        2: 1210:                return 1;           // Signal: option found and parameter read
        -: 1211:            }
        -: 1212:        }
        -: 1213:    }
        -: 1214:
        -: 1215:    // The current test option was not the one recently read from command line
      142: 1216:    return 0;
        -: 1217:}
        -: 1218:
        -: 1219:
        -: 1220:
        -: 1221://==============================================================================
        -: 1222:// info
        -: 1223://
        -: 1224:// Print informative usage message to stream passed as argument
        -: 1225://
        -: 1226:
        7: 1227:static void  info (
        -: 1228:    FILE *const  file
        -: 1229:) {
        7: 1230:    if (file != stderr) {
        2: 1231:        fputs (LOGO": Generate code to compute an FFT or IFFT\n"
        -: 1232:               "Version: "VERSION"\n\n", file);
        -: 1233:    }
        7: 1234:    fputs (
        -: 1235:        "Usage: fftGen [option...]\n"
        -: 1236:        "Options:\n"
        -: 1237:        "Mandatory arguments to long options are mandatory for short options too.\n"
        -: 1238:        " -n, --points NUMBER   Number of points, must be a power of 2.\n"
        -: 1239:        " -i, --inverse         Generate code for inverse FFT.\n"
        -: 1240:        " -r, --real-in-opt     Optimize for real only input.\n"
        -: 1241:        " -o, --real-out-opt    Optimize for real only output.\n"
        -: 1242:        " -m, --symm-in-opt     Optimize for symmetry at input sequence.\n"
        -: 1243:        " -s, --symm-out-opt    Optimize for symmetry at output sequence.\n"
        -: 1244:        " -l, --license         Write a GPL 3 note at the beginning of the code.\n"
        -: 1245:        " -v, --verbose         Increase verbosity level.\n"
        -: 1246:        "                       Verbose output is directed to stderr.\n"
        -: 1247:        " -V, --version         Print version and exit.\n"
        -: 1248:        " -h, --help            Print this info.\n"
        -: 1249:        "Note that it is required to specify the number of data points by option -n\n"
        -: 1250:        "or --points.\n"
        -: 1251:        "Result is written to stdout\n", file);
        -: 1252:
        7: 1253:    if (file == stderr)  exit (EXIT_FAILURE);
        2: 1254:    else                 exit (EXIT_SUCCESS);
        -: 1255:}
