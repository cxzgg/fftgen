<html><head><title>fftGen.c</title>
<style type='text/css'><!--
pre{font-size:x-small}
.n{color:#4040FF}.e{color:#00D000}.p{color:#F08000}.u{color:#FF0000}.c{color:#808080}
--></style>
</head>
<body><pre>
<span class='n'>0:</span> <span class='h'>Source:../fftGen.c</span>
<span class='n'>0:</span> <span class='h'>Graph:fftGen.gcno</span>
<span class='n'>0:</span> <span class='h'>Data:fftGen.gcda</span>
<span class='n'>0:</span> <span class='h'>Runs:35</span>
&nbsp;&nbsp;&nbsp;<span class='h'>Legend:</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='c'>No code</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='e'>Executed</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='p'>Partly executed</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='u'>Unexecuted</span>
<span class='n'>1:</span> <span class='c'>//##############################################################################</span>
<span class='n'>2:</span> <span class='c'>// File: fftGen.c</span>
<span class='n'>3:</span> <span class='c'>//</span>
<span class='n'>4:</span> <span class='c'>// Version 1     2021 Jun 21st   jost.brachert@gmx.de</span>
<span class='n'>5:</span> <span class='c'>//</span>
<span class='n'>6:</span> <span class='c'>// Generate C code to compute a Fast Fourier Transform (FFT) and an Inverse Fast</span>
<span class='n'>7:</span> <span class='c'>// Fourier Transform (IFFT).</span>
<span class='n'>8:</span> <span class='c'>// Target of the generated code is to compute the algorithms in a very fast way.</span>
<span class='n'>9:</span> <span class='c'>// This is achieved by</span>
<span class='n'>10:</span> <span class='c'>// a) unrolling the loops,</span>
<span class='n'>11:</span> <span class='c'>// b) removing operations where sequence elements are multiplied by sine or</span>
<span class='n'>12:</span> <span class='c'>//    cosine function values being zero or one,</span>
<span class='n'>13:</span> <span class='c'>// c) optionally removing operations which are obsolete in certain</span>
<span class='n'>14:</span> <span class='c'>//    circumstances, see documentation for details.</span>
<span class='n'>15:</span> <span class='c'>// Note that optimization a) is at the expense of code size.</span>
<span class='n'>16:</span> <span class='c'>//</span>
<span class='n'>17:</span> <span class='c'>//------------------------------------------------------------------------------</span>
<span class='n'>18:</span> <span class='c'>// Copyright (C) 2021  Jost Brachert, jost.brachert@gmx.de</span>
<span class='n'>19:</span> <span class='c'>//</span>
<span class='n'>20:</span> <span class='c'>// This program is free software: you can redistribute it and/or modify it under</span>
<span class='n'>21:</span> <span class='c'>// the terms of the GNU General Public License as published by the Free Software</span>
<span class='n'>22:</span> <span class='c'>// Foundation; either version 3 of the license, or (at your option) any later</span>
<span class='n'>23:</span> <span class='c'>// version.</span>
<span class='n'>24:</span> <span class='c'>//</span>
<span class='n'>25:</span> <span class='c'>// This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class='n'>26:</span> <span class='c'>// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class='n'>27:</span> <span class='c'>// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class='n'>28:</span> <span class='c'>// details.</span>
<span class='n'>29:</span> <span class='c'>//</span>
<span class='n'>30:</span> <span class='c'>// You should have received a copy of the GNU General Public License along with</span>
<span class='n'>31:</span> <span class='c'>// this program, see file COPYING. If not, see https://www.gnu.org/licenses/.</span>
<span class='n'>32:</span> <span class='c'>//</span>
<span class='n'>33:</span> <span class='c'></span>
<span class='n'>34:</span> <span class='c'>/*!</span>
<span class='n'>35:</span> <span class='c'>\mainpage fftGen</span>
<span class='n'>36:</span> <span class='c'></span>
<span class='n'>37:</span> <span class='c'>\section Name  NAME</span>
<span class='n'>38:</span> <span class='c'></span>
<span class='n'>39:</span> <span class='c'>fftGen - Generate code to compute an FFT or IFFT</span>
<span class='n'>40:</span> <span class='c'></span>
<span class='n'>41:</span> <span class='c'></span>
<span class='n'>42:</span> <span class='c'></span>
<span class='n'>43:</span> <span class='c'>\section Synopsis  SYNOPSIS</span>
<span class='n'>44:</span> <span class='c'></span>
<span class='n'>45:</span> <span class='c'>\b fftGen [option]...</span>
<span class='n'>46:</span> <span class='c'></span>
<span class='n'>47:</span> <span class='c'>\par Options:</span>
<span class='n'>48:</span> <span class='c'>[\c -n \e number] [\c \--points \e number]</span>
<span class='n'>49:</span> <span class='c'>[\c -i] [\c \--inverse]</span>
<span class='n'>50:</span> <span class='c'>[\c -r] [\c \--real-in-opt]</span>
<span class='n'>51:</span> <span class='c'>[\c -o] [\c \--real-out-opt]</span>
<span class='n'>52:</span> <span class='c'>[\c -m] [\c \--symm-in-opt]</span>
<span class='n'>53:</span> <span class='c'>[\c -s] [\c \--symm-out-opt]</span>
<span class='n'>54:</span> <span class='c'>[\c -l] [\c \--license]</span>
<span class='n'>55:</span> <span class='c'>[\c -v] [\c \--verbose]</span>
<span class='n'>56:</span> <span class='c'>[\c -V] [\c \--version]</span>
<span class='n'>57:</span> <span class='c'>[\c -h] [\c \--help]</span>
<span class='n'>58:</span> <span class='c'></span>
<span class='n'>59:</span> <span class='c'>Note that it is \e required to specify the number of data points with options</span>
<span class='n'>60:</span> <span class='c'>\c -n or \c \--points.</span>
<span class='n'>61:</span> <span class='c'></span>
<span class='n'>62:</span> <span class='c'></span>
<span class='n'>63:</span> <span class='c'></span>
<span class='n'>64:</span> <span class='c'>\section Description DESCRIPTION</span>
<span class='n'>65:</span> <span class='c'></span>
<span class='n'>66:</span> <span class='c'>The program generates code to compute a Fast Fourier Transform (FFT) or Inverse</span>
<span class='n'>67:</span> <span class='c'>Fast Fourier Transform (IFFT) for the C or C++ programming language. Target of</span>
<span class='n'>68:</span> <span class='c'>the generated code is to compute the algorithms in a very fast way.</span>
<span class='n'>69:</span> <span class='c'></span>
<span class='n'>70:</span> <span class='c'>The program needs to know the number of data points for the FFT. Either option</span>
<span class='n'>71:</span> <span class='c'>\c -n or \c \-\-points must therefore always be specified when the program is</span>
<span class='n'>72:</span> <span class='c'>called. The value of these options specifies the number of data points. It must</span>
<span class='n'>73:</span> <span class='c'>always be a power of two and it must not be zero. It may be equal one, however,</span>
<span class='n'>74:</span> <span class='c'>value one doesn't make much sense because in that case no code is produced.</span>
<span class='n'>75:</span> <span class='c'></span>
<span class='n'>76:</span> <span class='c'>If the program shall compute an inverse FFT then option \c -i or \c \-\-inverse</span>
<span class='n'>77:</span> <span class='c'>must be given as argument. Note that in this case the result is scaled by</span>
<span class='n'>78:</span> <span class='c'>\c n if \c n is the number of data points. To get the correct result of an</span>
<span class='n'>79:</span> <span class='c'>inverse FFT the results of the generated code must be divided by \c n.</span>
<span class='n'>80:</span> <span class='c'></span>
<span class='n'>81:</span> <span class='c'>The transform is conducted \"in place\", that means the resulting output</span>
<span class='n'>82:</span> <span class='c'>sequence overwrites the input sequence.</span>
<span class='n'>83:</span> <span class='c'></span>
<span class='n'>84:</span> <span class='c'></span>
<span class='n'>85:</span> <span class='c'>\subsection Optimizations Optimizations</span>
<span class='n'>86:</span> <span class='c'></span>
<span class='n'>87:</span> <span class='c'>The speed of computation is achieved by a number of optimizations of the</span>
<span class='n'>88:</span> <span class='c'>standard Cooley-Tukey algorithm:</span>
<span class='n'>89:</span> <span class='c'></span>
<span class='n'>90:</span> <span class='c'>1. Precomputing sine and cosine function values</span>
<span class='n'>91:</span> <span class='c'></span>
<span class='n'>92:</span> <span class='c'>   During an FFT a lot of sine and cosine function values are to be computed.</span>
<span class='n'>93:</span> <span class='c'>   Computation of these function values is time-consuming. However, they are</span>
<span class='n'>94:</span> <span class='c'>   fixed and known for any FFT of a certain number of data points. It is thus</span>
<span class='n'>95:</span> <span class='c'>   possible to compute those function values once before conducting the actual</span>
<span class='n'>96:</span> <span class='c'>   transform - at best already at compile time.</span>
<span class='n'>97:</span> <span class='c'></span>
<span class='n'>98:</span> <span class='c'>2. Unrolling loops</span>
<span class='n'>99:</span> <span class='c'></span>
<span class='n'>100:</span> <span class='c'>   The FFT is usually computed in several loops. However, executing the loop</span>
<span class='n'>101:</span> <span class='c'>   control statements needs some time. That time can be saved if the loops are</span>
<span class='n'>102:</span> <span class='c'>   unrolled, that means, instead of jumping from the end of a loop to its</span>
<span class='n'>103:</span> <span class='c'>   beginning the statements of the loop are copied in series.</span>
<span class='n'>104:</span> <span class='c'></span>
<span class='n'>105:</span> <span class='c'>   Drawback is certainly that the size of program increases.</span>
<span class='n'>106:</span> <span class='c'></span>
<span class='n'>107:</span> <span class='c'>3. Inserting precomputed sine and cosine function values immediately into the</span>
<span class='n'>108:</span> <span class='c'>   algorithm</span>
<span class='n'>109:</span> <span class='c'></span>
<span class='n'>110:</span> <span class='c'>   Both abovementioned optimizations offer this possibility. The precomputed</span>
<span class='n'>111:</span> <span class='c'>   function values can be inserted as literal constants directly into the source</span>
<span class='n'>112:</span> <span class='c'>   code of the unrolled loops. The access to those immediate constants is much</span>
<span class='n'>113:</span> <span class='c'>   faster than the indirect access to an array which would contain the</span>
<span class='n'>114:</span> <span class='c'>   precomputed values otherwise.</span>
<span class='n'>115:</span> <span class='c'></span>
<span class='n'>116:</span> <span class='c'>   However, this comes also at the downside of increased code size.</span>
<span class='n'>117:</span> <span class='c'></span>
<span class='n'>118:</span> <span class='c'>4. Removing multiplications by one</span>
<span class='n'>119:</span> <span class='c'></span>
<span class='n'>120:</span> <span class='c'>5. Removing summands in expressions which are the result of a multiplication by</span>
<span class='n'>121:</span> <span class='c'>   zero</span>
<span class='n'>122:</span> <span class='c'></span>
<span class='n'>123:</span> <span class='c'>6. Removing all operations assumed to be obsolete because the input sequence</span>
<span class='n'>124:</span> <span class='c'>   consists of real values only</span>
<span class='n'>125:</span> <span class='c'></span>
<span class='n'>126:</span> <span class='c'>   This optimization is optional because it will produce wrong results if the</span>
<span class='n'>127:</span> <span class='c'>   input sequence contains non-zero imaginary values.</span>
<span class='n'>128:</span> <span class='c'></span>
<span class='n'>129:</span> <span class='c'>   To activate this optimization use option \c -r.</span>
<span class='n'>130:</span> <span class='c'></span>
<span class='n'>131:</span> <span class='c'>   If this option is specified then it is not necessary to initialize the array</span>
<span class='n'>132:</span> <span class='c'>   for imaginary values because these values are ignored.</span>
<span class='n'>133:</span> <span class='c'></span>
<span class='n'>134:</span> <span class='c'>7. Removing all operations required to calculate points in the second half of</span>
<span class='n'>135:</span> <span class='c'>   the FFT result sequence</span>
<span class='n'>136:</span> <span class='c'></span>
<span class='n'>137:</span> <span class='c'>   If the input sequence consists of real values only then the values of the</span>
<span class='n'>138:</span> <span class='c'>   resulting sequence are symmetrical to the value with index n/2 (indices</span>
<span class='n'>139:</span> <span class='c'>   starting at 0) if n is the number of data points - according to the following</span>
<span class='n'>140:</span> <span class='c'>   expression:</span>
<span class='n'>141:</span> <span class='c'>   \code</span>
<span class='n'>142:</span> <span class='c'>     x[i] = x*[n-i]     for i=n/2+1...n-1</span>
<span class='n'>143:</span> <span class='c'>   \endcode</span>
<span class='n'>144:</span> <span class='c'>   x*[n-i] denoting the conjugate complex value to x[n-i]. The conjugate complex</span>
<span class='n'>145:</span> <span class='c'>   value of complex variable z has the same real value and the negative</span>
<span class='n'>146:</span> <span class='c'>   imaginary value of z.</span>
<span class='n'>147:</span> <span class='c'></span>
<span class='n'>148:</span> <span class='c'>   It is thus not necessary to calculate the points from n/2+1 on. They are</span>
<span class='n'>149:</span> <span class='c'>   usually not required and if needed they can anyway be calculated later in the</span>
<span class='n'>150:</span> <span class='c'>   way described above.</span>
<span class='n'>151:</span> <span class='c'></span>
<span class='n'>152:</span> <span class='c'>   This optimization is optional because it will produce wrong results if the</span>
<span class='n'>153:</span> <span class='c'>   input sequence contains non-zero imaginary values.</span>
<span class='n'>154:</span> <span class='c'></span>
<span class='n'>155:</span> <span class='c'>   To activate this optimization use option \c -s.</span>
<span class='n'>156:</span> <span class='c'></span>
<span class='n'>157:</span> <span class='c'>   Note that if this option is specified then the points from n/2+1 onwards</span>
<span class='n'>158:</span> <span class='c'>   contain useless arbitrary values.</span>
<span class='n'>159:</span> <span class='c'></span>
<span class='n'>160:</span> <span class='c'>8. Removing all operations assumed to be obsolete because the output sequence</span>
<span class='n'>161:</span> <span class='c'>   consists of real values only</span>
<span class='n'>162:</span> <span class='c'></span>
<span class='n'>163:</span> <span class='c'>   This optimization is optional because it will produce wrong results if the</span>
<span class='n'>164:</span> <span class='c'>   input sequence will produce non-zero imaginary values in the result sequence.</span>
<span class='n'>165:</span> <span class='c'></span>
<span class='n'>166:</span> <span class='c'>   To activate this optimization use option \c -o.</span>
<span class='n'>167:</span> <span class='c'></span>
<span class='n'>168:</span> <span class='c'>   The output sequence contains real only values in case of an IFFT with an</span>
<span class='n'>169:</span> <span class='c'>   input sequence being the result of an FFT with real only input.</span>
<span class='n'>170:</span> <span class='c'></span>
<span class='n'>171:</span> <span class='c'>   Note that a lot of manipulations of the result of the FFT that was used to</span>
<span class='n'>172:</span> <span class='c'>   generate the IFFT input sequence will spoil the property of generating real</span>
<span class='n'>173:</span> <span class='c'>   only output values in that IFFT. So use that option with care. It might be a</span>
<span class='n'>174:</span> <span class='c'>   good idea to first check the IFFT result before using this option.</span>
<span class='n'>175:</span> <span class='c'></span>
<span class='n'>176:</span> <span class='c'>   Note that if this option is specified then the imaginary values in the result</span>
<span class='n'>177:</span> <span class='c'>   sequence contain useless arbitrary values.</span>
<span class='n'>178:</span> <span class='c'></span>
<span class='n'>179:</span> <span class='c'>9. Removing all operations being obsolete because the input sequence is assumed</span>
<span class='n'>180:</span> <span class='c'>   to be symmetrical around the value with index n/2+1 (indices starting at 0)</span>
<span class='n'>181:</span> <span class='c'>   if n is the number of data points</span>
<span class='n'>182:</span> <span class='c'></span>
<span class='n'>183:</span> <span class='c'>   For the exact assumed symmetry relationship see abovementioned</span>
<span class='n'>184:</span> <span class='c'>   optimization 7. A sequence gets that kind of symmetry if it is the result of</span>
<span class='n'>185:</span> <span class='c'>   an FFT (or IFFT) with real only input data points.</span>
<span class='n'>186:</span> <span class='c'></span>
<span class='n'>187:</span> <span class='c'>   To activate this optimization use option \c -m.</span>
<span class='n'>188:</span> <span class='c'></span>
<span class='n'>189:</span> <span class='c'>   If this option is specified then it is not necessary to initialize the arrays</span>
<span class='n'>190:</span> <span class='c'>   for real and imaginary values from the value with index n/2+1 onwards</span>
<span class='n'>191:</span> <span class='c'>   (indices starting at 0) because these values are ignored.</span>
<span class='n'>192:</span> <span class='c'></span>
<span class='n'>193:</span> <span class='c'></span>
<span class='n'>194:</span> <span class='c'></span>
<span class='n'>195:</span> <span class='c'>\subsection Combinations Combinations of Optimizations</span>
<span class='n'>196:</span> <span class='c'></span>
<span class='n'>197:</span> <span class='c'>Optimizations 6. and 7. (options \c -r and \c -s) are both for real only</span>
<span class='n'>198:</span> <span class='c'>input sequences for normal FFT and are therefore usually specified together.</span>
<span class='n'>199:</span> <span class='c'></span>
<span class='n'>200:</span> <span class='c'>Optimizations 8. and 9. (options \c -o and \c -m) are both for symmetrical input</span>
<span class='n'>201:</span> <span class='c'>sequences for FFTs and IFFTs and are therefore usually specified together.</span>
<span class='n'>202:</span> <span class='c'></span>
<span class='n'>203:</span> <span class='c'>Optimization 8. (option \c -o) is usually for inverse FFTs only. It thus does</span>
<span class='n'>204:</span> <span class='c'>not make much sense to combine it with options \c -r or \c -s.</span>
<span class='n'>205:</span> <span class='c'></span>
<span class='n'>206:</span> <span class='c'></span>
<span class='n'>207:</span> <span class='c'></span>
<span class='n'>208:</span> <span class='c'>\section Size Size of the Generated Code</span>
<span class='n'>209:</span> <span class='c'></span>
<span class='n'>210:</span> <span class='c'>Unrolling the loops increases the code size drastically. If \c m is the power of</span>
<span class='n'>211:</span> <span class='c'>two exponent to compute the number of data points of the FFT then the generated</span>
<span class='n'>212:</span> <span class='c'>lines of code for the FFT internal binary inversion algorithm can be computed by</span>
<span class='n'>213:</span> <span class='c'>\code</span>
<span class='n'>214:</span> <span class='c'>LOC_B = 2**(m/2) - 2**((m-1)/2) * 6</span>
<span class='n'>215:</span> <span class='c'>\endcode</span>
<span class='n'>216:</span> <span class='c'>\*\* means exponentiation</span>
<span class='n'>217:</span> <span class='c'></span>
<span class='n'>218:</span> <span class='c'>The generated lines of code for the rest of the FFT transform can be calculated</span>
<span class='n'>219:</span> <span class='c'>by</span>
<span class='n'>220:</span> <span class='c'>\code</span>
<span class='n'>221:</span> <span class='c'>LOC_T = m*2**(m-1) * 6</span>
<span class='n'>222:</span> <span class='c'>\endcode</span>
<span class='n'>223:</span> <span class='c'>The total number of code lines for a certain number \c n of FFT data points is</span>
<span class='n'>224:</span> <span class='c'>\code</span>
<span class='n'>225:</span> <span class='c'>m   n       LOC_B   LOC_T   Total</span>
<span class='n'>226:</span> <span class='c'>3   8       12      72      84</span>
<span class='n'>227:</span> <span class='c'>4   16      36      192     228</span>
<span class='n'>228:</span> <span class='c'>5   32      72      480     552</span>
<span class='n'>229:</span> <span class='c'>6   64      168     1152    1320</span>
<span class='n'>230:</span> <span class='c'>7   128     336     2688    3024</span>
<span class='n'>231:</span> <span class='c'>8   256     720     6144    6844</span>
<span class='n'>232:</span> <span class='c'>9   512     1440    13824   15264</span>
<span class='n'>233:</span> <span class='c'>10  1024    2976    30720   33696</span>
<span class='n'>234:</span> <span class='c'>\endcode</span>
<span class='n'>235:</span> <span class='c'>Optimizations 6. to 9. will reduce the number of code lines a bit. For</span>
<span class='n'>236:</span> <span class='c'>&lt;tt&gt;m&lt;/tt&gt;=5 (i.e. &lt;tt&gt;n&lt;/tt&gt;=32) with optimizations 6. and 7. (options \c -r</span>
<span class='n'>237:</span> <span class='c'>and \c -s) the total number of code lines reduces to 365.</span>
<span class='n'>238:</span> <span class='c'></span>
<span class='n'>239:</span> <span class='c'></span>
<span class='n'>240:</span> <span class='c'></span>
<span class='n'>241:</span> <span class='c'>\section Integration INTEGRATION</span>
<span class='n'>242:</span> <span class='c'></span>
<span class='n'>243:</span> <span class='c'>The program generates the FFT code only, no function header and no function</span>
<span class='n'>244:</span> <span class='c'>ending. The generated code requires some defined variables:</span>
<span class='n'>245:</span> <span class='c'>- Two defined arrays for the complex sequence points, in particular</span>
<span class='n'>246:</span> <span class='c'>  - array &lt;tt&gt;xr[]&lt;/tt&gt; for the real values and</span>
<span class='n'>247:</span> <span class='c'>  - array &lt;tt&gt;xi[]&lt;/tt&gt;.</span>
<span class='n'>248:</span> <span class='c'>  .</span>
<span class='n'>249:</span> <span class='c'>  Both arrays must be of size \c n, where \c n is the number of data points of</span>
<span class='n'>250:</span> <span class='c'>  the FFT or IFFT.</span>
<span class='n'>251:</span> <span class='c'>- Two variables to store intermediate values:</span>
<span class='n'>252:</span> <span class='c'>  - &lt;tt&gt;tr&lt;/tt&gt; and</span>
<span class='n'>253:</span> <span class='c'>  - &lt;tt&gt;ti&lt;/tt&gt;.</span>
<span class='n'>254:</span> <span class='c'></span>
<span class='n'>255:</span> <span class='c'>Advantage of this approach is that no assumption is required for the generated</span>
<span class='n'>256:</span> <span class='c'>code regarding the concrete type of the involved variables. The arrays and</span>
<span class='n'>257:</span> <span class='c'>variables can therefore be of any valid floating point type, e.g. \c double or</span>
<span class='n'>258:</span> <span class='c'>\c float.</span>
<span class='n'>259:</span> <span class='c'></span>
<span class='n'>260:</span> <span class='c'>The generated code can easiest be integrated if it is piped to a file which is</span>
<span class='n'>261:</span> <span class='c'>then included via an \c \#include preprocessor statement into a function body</span>
<span class='n'>262:</span> <span class='c'>that provides the required definitions.</span>
<span class='n'>263:</span> <span class='c'></span>
<span class='n'>264:</span> <span class='c'>\b Example:</span>
<span class='n'>265:</span> <span class='c'></span>
<span class='n'>266:</span> <span class='c'>Assumed the generated code has been written to file \c fft.c and the FFT should</span>
<span class='n'>267:</span> <span class='c'>be computed in \c float arithmetic. Then the according code could look like</span>
<span class='n'>268:</span> <span class='c'>\code</span>
<span class='n'>269:</span> <span class='c'>void  fft (float *xr, float *xi) {</span>
<span class='n'>270:</span> <span class='c'>    float  tr, ti;</span>
<span class='n'>271:</span> <span class='c'>#include "fft.c"</span>
<span class='n'>272:</span> <span class='c'>}</span>
<span class='n'>273:</span> <span class='c'>\endcode</span>
<span class='n'>274:</span> <span class='c'></span>
<span class='n'>275:</span> <span class='c'>Function &lt;tt&gt;fft()&lt;/tt&gt; can now be called to compute the FFT. The calling</span>
<span class='n'>276:</span> <span class='c'>program must</span>
<span class='n'>277:</span> <span class='c'>- define the two arrays and</span>
<span class='n'>278:</span> <span class='c'>- fill them with the input values for the FFT,</span>
<span class='n'>279:</span> <span class='c'>- then call function &lt;tt&gt;fft()&lt;/tt&gt; with the pointers to those arrays as</span>
<span class='n'>280:</span> <span class='c'>  arguments,</span>
<span class='n'>281:</span> <span class='c'>- take the resulting transformed values from the arrays.</span>
<span class='n'>282:</span> <span class='c'>- In case of an inverse FFT the results must be divided by \c n the number of</span>
<span class='n'>283:</span> <span class='c'>  the data points.</span>
<span class='n'>284:</span> <span class='c'></span>
<span class='n'>285:</span> <span class='c'></span>
<span class='n'>286:</span> <span class='c'></span>
<span class='n'>287:</span> <span class='c'>\section Options  OPTIONS</span>
<span class='n'>288:</span> <span class='c'></span>
<span class='n'>289:</span> <span class='c'>\par \c -n, \c \-\-points \e number</span>
<span class='n'>290:</span> <span class='c'>Number of data points of the FFT. The number must be a power of two.\n</span>
<span class='n'>291:</span> <span class='c'>This option is not optional. It must be given to specify the required number of</span>
<span class='n'>292:</span> <span class='c'>data points.</span>
<span class='n'>293:</span> <span class='c'></span>
<span class='n'>294:</span> <span class='c'>\par \c -i, \c \-\-inverse</span>
<span class='n'>295:</span> <span class='c'>Generate code to calculate an inverse FFT.</span>
<span class='n'>296:</span> <span class='c'></span>
<span class='n'>297:</span> <span class='c'>\par \c -r, \c \-\-real-in-opt</span>
<span class='n'>298:</span> <span class='c'>Optimize the code assuming that the imaginary input values are all zero, see</span>
<span class='n'>299:</span> <span class='c'>\ref Optimizations.</span>
<span class='n'>300:</span> <span class='c'></span>
<span class='n'>301:</span> <span class='c'>\par \c -o, \c \-\-real-out-opt</span>
<span class='n'>302:</span> <span class='c'>Optimize the code assuming that in the result sequence all imaginary values are</span>
<span class='n'>303:</span> <span class='c'>zero. This is the case for an IFFT with an input sequence being the result of an</span>
<span class='n'>304:</span> <span class='c'>FFT with real only input. Use with care, see \ref Optimizations.</span>
<span class='n'>305:</span> <span class='c'></span>
<span class='n'>306:</span> <span class='c'>\par \c -s, \c \-\-symm-out-opt</span>
<span class='n'>307:</span> <span class='c'>Optimize the code assuming that the FFT result is symmetrical to element n/2 if</span>
<span class='n'>308:</span> <span class='c'>n is the number of data points passed with option \c -n (indices starting at 0).</span>
<span class='n'>309:</span> <span class='c'>The result of the FFT is symmetrical around n/2 if the imaginary input values</span>
<span class='n'>310:</span> <span class='c'>are all zero. For details see \ref Optimizations.</span>
<span class='n'>311:</span> <span class='c'></span>
<span class='n'>312:</span> <span class='c'>\par \c -m, \c \-\-symm-in-opt</span>
<span class='n'>313:</span> <span class='c'>Optimize the code assuming that the FFT input sequence is symmetrical to element</span>
<span class='n'>314:</span> <span class='c'>n/2 if n is the number of data points passed with option \c -n (indices starting</span>
<span class='n'>315:</span> <span class='c'>at 0), see \ref Optimizations.</span>
<span class='n'>316:</span> <span class='c'></span>
<span class='n'>317:</span> <span class='c'>\par \c -l, \c \-\-license</span>
<span class='n'>318:</span> <span class='c'>Write a short GPL 3 license note at the beginning of the generated code.</span>
<span class='n'>319:</span> <span class='c'></span>
<span class='n'>320:</span> <span class='c'>\par \c -v, \c \-\-verbose</span>
<span class='n'>321:</span> <span class='c'>Increase verbosity level, can be specified more than once. On level one writes</span>
<span class='n'>322:</span> <span class='c'>the chosen options to \c stderr.</span>
<span class='n'>323:</span> <span class='c'></span>
<span class='n'>324:</span> <span class='c'>\par \c -V, \c \-\-version</span>
<span class='n'>325:</span> <span class='c'>Print version information and exit.</span>
<span class='n'>326:</span> <span class='c'></span>
<span class='n'>327:</span> <span class='c'>\par \c -h, \c \-\-help</span>
<span class='n'>328:</span> <span class='c'>Print this info.</span>
<span class='n'>329:</span> <span class='c'></span>
<span class='n'>330:</span> <span class='c'></span>
<span class='n'>331:</span> <span class='c'></span>
<span class='n'>332:</span> <span class='c'>\section ExitStatus  EXIT STATUS</span>
<span class='n'>333:</span> <span class='c'></span>
<span class='n'>334:</span> <span class='c'>If no errors occurred in the course of the program the program terminates with</span>
<span class='n'>335:</span> <span class='c'>exit code \c 0. Otherwise it returns a system dependent error code different</span>
<span class='n'>336:</span> <span class='c'>from zero, see \c man \c stdlib.h -&gt; \c EXIT_FAILURE.</span>
<span class='n'>337:</span> <span class='c'></span>
<span class='n'>338:</span> <span class='c'></span>
<span class='n'>339:</span> <span class='c'></span>
<span class='n'>340:</span> <span class='c'>\section Diagnostics  DIAGNOSTICS</span>
<span class='n'>341:</span> <span class='c'></span>
<span class='n'>342:</span> <span class='c'>Error messages are routed to \c stderr. They are sometimes accompanied by a</span>
<span class='n'>343:</span> <span class='c'>more detailed error description.</span>
<span class='n'>344:</span> <span class='c'></span>
<span class='n'>345:</span> <span class='c'>\par \"Unknown argument\"</span>
<span class='n'>346:</span> <span class='c'>\par \"Unknown option\"</span>
<span class='n'>347:</span> <span class='c'>\par \"Invalid option argument\"</span>
<span class='n'>348:</span> <span class='c'>Wrong command line argument or option. See \ref Synopsis or \ref Options.</span>
<span class='n'>349:</span> <span class='c'></span>
<span class='n'>350:</span> <span class='c'>\par \"Error allocating memory\"</span>
<span class='n'>351:</span> <span class='c'>Not enough heap memory available. It might help to close some applications.</span>
<span class='n'>352:</span> <span class='c'></span>
<span class='n'>353:</span> <span class='c'>\par \"No number of points specified\"</span>
<span class='n'>354:</span> <span class='c'>The number of points must be specified using option \c -n. It must be a power of</span>
<span class='n'>355:</span> <span class='c'>two. See \ref Synopsis or \ref Options.</span>
<span class='n'>356:</span> <span class='c'></span>
<span class='n'>357:</span> <span class='c'>\par \"Number of points is not a power of two\"</span>
<span class='n'>358:</span> <span class='c'>The number of data points specified with option \c -n must be a power of two.</span>
<span class='n'>359:</span> <span class='c'>See \ref Description or \ref Options.</span>
<span class='n'>360:</span> <span class='c'></span>
<span class='n'>361:</span> <span class='c'></span>
<span class='n'>362:</span> <span class='c'></span>
<span class='n'>363:</span> <span class='c'>\section KnownBugs  KNOWN BUGS</span>
<span class='n'>364:</span> <span class='c'></span>
<span class='n'>365:</span> <span class='c'>Not yet known. If you find one send an according note to the author.</span>
<span class='n'>366:</span> <span class='c'></span>
<span class='n'>367:</span> <span class='c'></span>
<span class='n'>368:</span> <span class='c'></span>
<span class='n'>369:</span> <span class='c'>\section Author  AUTHOR</span>
<span class='n'>370:</span> <span class='c'></span>
<span class='n'>371:</span> <span class='c'>jost.brachert@gmx.de</span>
<span class='n'>372:</span> <span class='c'></span>
<span class='n'>373:</span> <span class='c'></span>
<span class='n'>374:</span> <span class='c'></span>
<span class='n'>375:</span> <span class='c'>\section Copyright  COPYRIGHT</span>
<span class='n'>376:</span> <span class='c'></span>
<span class='n'>377:</span> <span class='c'>Copyright (C) 2021  Jost Brachert, jost.brachert@gmx.de</span>
<span class='n'>378:</span> <span class='c'></span>
<span class='n'>379:</span> <span class='c'>This program is free software: you can redistribute it and/or modify it under</span>
<span class='n'>380:</span> <span class='c'>the terms of the GNU General Public License as published by the Free Software</span>
<span class='n'>381:</span> <span class='c'>Foundation; either version 3 of the license, or (at your option) any later</span>
<span class='n'>382:</span> <span class='c'>version.</span>
<span class='n'>383:</span> <span class='c'></span>
<span class='n'>384:</span> <span class='c'>This program is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class='n'>385:</span> <span class='c'>WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A</span>
<span class='n'>386:</span> <span class='c'>PARTICULAR PURPOSE. See the GNU General Public License for more details.</span>
<span class='n'>387:</span> <span class='c'></span>
<span class='n'>388:</span> <span class='c'>You should have received a copy of the GNU General Public License along with</span>
<span class='n'>389:</span> <span class='c'>this program, see file COPYING. If not, see https://www.gnu.org/licenses/.</span>
<span class='n'>390:</span> <span class='c'></span>
<span class='n'>391:</span> <span class='c'>*/</span>
<span class='n'>392:</span> <span class='c'></span>
<span class='n'>393:</span> <span class='c'></span>
<span class='n'>394:</span> <span class='c'></span>
<span class='n'>395:</span> <span class='c'>#include  &lt;stdio.h&gt;</span>
<span class='n'>396:</span> <span class='c'>#include   &lt;math.h&gt;     // sin(),cos(),fabs()</span>
<span class='n'>397:</span> <span class='c'>#include &lt;string.h&gt;     // strlen(),strcat(),strncpy(),strcmp(),strerror()</span>
<span class='n'>398:</span> <span class='c'>#include &lt;stdlib.h&gt;     // malloc(),exit(),free(),EXIT_SUCCESS,EXIT_FAILURE,NULL</span>
<span class='n'>399:</span> <span class='c'>#include  &lt;errno.h&gt;     // errno</span>
<span class='n'>400:</span> <span class='c'></span>
<span class='n'>401:</span> <span class='c'>#define  LOGO       "fftGen"</span>
<span class='n'>402:</span> <span class='c'>#define  VERSION    "V1"</span>
<span class='n'>403:</span> <span class='c'></span>
<span class='n'>404:</span> <span class='c'>#define  OPTIMIZE_SINE_COSINE_VALUES</span>
<span class='n'>405:</span> <span class='c'></span>
<span class='n'>406:</span> <span class='c'>//------------------------------------------------------------------------------</span>
<span class='n'>407:</span> <span class='c'>// Options for formatting of the generated source code</span>
<span class='n'>408:</span> <span class='c'></span>
<span class='n'>409:</span> <span class='c'>#ifndef NUMBER_FORMAT</span>
<span class='n'>410:</span> <span class='c'>#define  NUMBER_FORMAT  "%21.14e"       // printf format for literal constants</span>
<span class='n'>411:</span> <span class='c'>#endif</span>
<span class='n'>412:</span> <span class='c'>#ifndef INDENT</span>
<span class='n'>413:</span> <span class='c'>#define  INDENT         ""              // Indentation of output code lines</span>
<span class='n'>414:</span> <span class='c'>#endif</span>
<span class='n'>415:</span> <span class='c'></span>
<span class='n'>416:</span> <span class='c'></span>
<span class='n'>417:</span> <span class='c'>//------------------------------------------------------------------------------</span>
<span class='n'>418:</span> <span class='c'>// Definitions and Declarations</span>
<span class='n'>419:</span> <span class='c'></span>
<span class='n'>420:</span> <span class='c'>static void  fftGen (int,int,int,int,int,int);  // Generating function</span>
<span class='n'>421:</span> <span class='c'></span>
<span class='n'>422:</span> <span class='c'></span>
<span class='n'>423:</span> <span class='c'>static char licenseText[] =</span>
<span class='n'>424:</span> <span class='c'>"// This program is free software: you can redistribute it and/or modify it under\n"</span>
<span class='n'>425:</span> <span class='c'>"// the terms of the GNU General Public License as published by the Free Software\n"</span>
<span class='n'>426:</span> <span class='c'>"// Foundation; either version 3 of the license, or (at your option) any later\n"</span>
<span class='n'>427:</span> <span class='c'>"// version.\n"</span>
<span class='n'>428:</span> <span class='c'>"//\n"</span>
<span class='n'>429:</span> <span class='c'>"// This program is distributed in the hope that it will be useful, but WITHOUT\n"</span>
<span class='n'>430:</span> <span class='c'>"// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"</span>
<span class='n'>431:</span> <span class='c'>"// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n"</span>
<span class='n'>432:</span> <span class='c'>"// details.\n"</span>
<span class='n'>433:</span> <span class='c'>"//\n"</span>
<span class='n'>434:</span> <span class='c'>"// You should have received a copy of the GNU General Public License along with\n"</span>
<span class='n'>435:</span> <span class='c'>"// this program, see file COPYING. If not, see https://www.gnu.org/licenses/.\n"</span>
<span class='n'>436:</span> <span class='c'>;</span>
<span class='n'>437:</span> <span class='c'>static char header[] = "";          // Starting code of the generated function</span>
<span class='n'>438:</span> <span class='c'>static char footer[] = "";          // Ending of the generated function</span>
<span class='n'>439:</span> <span class='c'></span>
<span class='n'>440:</span> <span class='c'></span>
<span class='n'>441:</span> <span class='c'>//------------------------------------------------------------------------------</span>
<span class='n'>442:</span> <span class='c'>// Command line option descriptor</span>
<span class='n'>443:</span> <span class='c'></span>
<span class='n'>444:</span> <span class='c'>typedef</span>
<span class='n'>445:</span> <span class='c'>    struct Option {</span>
<span class='n'>446:</span> <span class='c'>            char  *shOpt;       // Name of short option</span>
<span class='n'>447:</span> <span class='c'>            char  *lgOpt;       // Name of long option (w/ one "-" before)</span>
<span class='n'>448:</span> <span class='c'>            char  *fmt;         // scanf format spec to read the value</span>
<span class='n'>449:</span> <span class='c'>            void  *val;         // Pointer to dest. value of the option</span>
<span class='n'>450:</span> <span class='c'>        }</span>
<span class='n'>451:</span> <span class='c'>            OPTION;</span>
<span class='n'>452:</span> <span class='c'></span>
<span class='n'>453:</span> <span class='c'>static int   checkOptions (int,const char*const*,int*,const OPTION*,int*);</span>
<span class='n'>454:</span> <span class='c'>static int   checkOption  (int,const char*const*,int*,const OPTION*);</span>
<span class='n'>455:</span> <span class='c'>static void  info (FILE*);</span>
<span class='n'>456:</span> <span class='c'></span>
<span class='n'>457:</span> <span class='c'></span>
<span class='n'>458:</span> <span class='c'></span>
<span class='n'>459:</span> <span class='c'>//==============================================================================</span>
<span class='n'>460:</span> <span class='c'>// main</span>
<span class='n'>461:</span> <span class='c'>//</span>
<span class='n'>462:</span> <span class='c'></span>
<span class='n'>463:</span> <span class='e'>int  main (</span>
<span class='n'>464:</span> <span class='c'>    const int    argc,</span>
<span class='n'>465:</span> <span class='c'>    const char  *argv[]</span>
<span class='n'>466:</span> <span class='c'>) {</span>
<span class='n'>467:</span> <span class='c'>    static int  n;       // Number of points for the FFT, must be a power of two</span>
<span class='n'>468:</span> <span class='c'>    static int  inv;     // Flag: !=0: Generate code for inverse FFT</span>
<span class='n'>469:</span> <span class='c'>    static int  realIn;  // Flag: !=0: Optimize for real only input</span>
<span class='n'>470:</span> <span class='c'>    static int  realOut; // Flag: !=0: Optimize for real only output</span>
<span class='n'>471:</span> <span class='c'>    static int  symmIn;  // Flag: !=0: Optimize for symmetry at input</span>
<span class='n'>472:</span> <span class='c'>    static int  symmOut; // Flag: !=0: Optimize for symmetry at output</span>
<span class='n'>473:</span> <span class='c'>    static int  verbose; // Level of verbosity</span>
<span class='n'>474:</span> <span class='c'>    static int  license; // Flag: !=0: Write a GPL 3 note at the beginning</span>
<span class='n'>475:</span> <span class='c'>#define  MAXOPT    50    // Must be greater than maximum length of short or</span>
<span class='n'>476:</span> <span class='c'>                         // long option strings (w/o parameter, including \0)</span>
<span class='n'>477:</span> <span class='c'>    static const OPTION  pOptions[] = {</span>
<span class='n'>478:</span> <span class='c'>        {"n", "-points"      , "%i", &amp;n      },</span>
<span class='n'>479:</span> <span class='c'>        {"i", "-inverse"     , NULL, &amp;inv    },</span>
<span class='n'>480:</span> <span class='c'>        {"r", "-real-in-opt" , NULL, &amp;realIn },</span>
<span class='n'>481:</span> <span class='c'>        {"o", "-real-out-opt", NULL, &amp;realOut},</span>
<span class='n'>482:</span> <span class='c'>        {"m", "-symm-in-opt" , NULL, &amp;symmIn },</span>
<span class='n'>483:</span> <span class='c'>        {"s", "-symm-out-opt", NULL, &amp;symmOut},</span>
<span class='n'>484:</span> <span class='c'>        {"l", "-license"     , NULL, &amp;license},</span>
<span class='n'>485:</span> <span class='c'>        {"v", "-verbose"     , NULL, &amp;verbose},</span>
<span class='n'>486:</span> <span class='c'>        {NULL, NULL          , NULL, NULL    }</span>
<span class='n'>487:</span> <span class='c'>    };</span>
<span class='n'>488:</span> <span class='c'></span>
<span class='n'>489:</span> <span class='c'>    //==========================================================================</span>
<span class='n'>490:</span> <span class='c'>    // Handle command line arguments</span>
<span class='n'>491:</span> <span class='c'>    int  i;</span>
<span class='n'>492:</span> <span class='e'>    for (i=1; i&lt;argc; i++) {</span>
<span class='n'>493:</span> <span class='c'>        // If a non-stand-alone '-'</span>
<span class='n'>494:</span> <span class='e'>        if (argv[i][0]=='-' &amp;&amp; argv[i][1]) {</span>
<span class='n'>495:</span> <span class='c'>            // Advance past '-' to</span>
<span class='n'>496:</span> <span class='c'>            //  - either check a long option (pOp-&gt;lgOpt contains an additional</span>
<span class='n'>497:</span> <span class='c'>            //    '-' as first character),</span>
<span class='n'>498:</span> <span class='c'>            //  - or check a short option. The while loop then advances to</span>
<span class='n'>499:</span> <span class='c'>            //    further concatenated short options.</span>
<span class='n'>500:</span> <span class='c'>            // The while loop terminates</span>
<span class='n'>501:</span> <span class='c'>            //  - either in its first cycle if the command line option is a</span>
<span class='n'>502:</span> <span class='c'>            //    long option,</span>
<span class='n'>503:</span> <span class='c'>            //  - or if a short option with a parameter has been encountered.</span>
<span class='n'>504:</span> <span class='e'>            while (*++argv[i]) {</span>
<span class='n'>505:</span> <span class='e'>                int  o = 0;</span>
<span class='n'>506:</span> <span class='e'>                int  ret = checkOptions (argc,argv,&amp;i,pOptions,&amp;o);</span>
<span class='n'>507:</span> <span class='e'>                if (ret == 1) {</span>
<span class='n'>508:</span> <span class='c'>                    // It was a param.option, or a long option w/o parameter, so</span>
<span class='n'>509:</span> <span class='c'>                    // leave short option loop</span>
<span class='n'>510:</span> <span class='e'>                    break;</span>
<span class='n'>511:</span> <span class='e'>                } else if (ret == -1) {</span>
<span class='n'>512:</span> <span class='c'>                    // Boolean short option (w/o parameter)</span>
<span class='n'>513:</span> <span class='c'>                    // If short option is longer than one character:</span>
<span class='n'>514:</span> <span class='e'>                    int  j = 0;</span>
<span class='n'>515:</span> <span class='e'>                    while (pOptions[o].shOpt[++j]) {</span>
<span class='n'>516:</span> <span class='u'>                        ++argv[i];          // Advance to next option in the</span>
<span class='n'>517:</span> <span class='c'>                    }                       // command line argument</span>
<span class='n'>518:</span> <span class='c'>                } else {</span>
<span class='n'>519:</span> <span class='c'>                    // ret==0: Option not found in the option list:</span>
<span class='n'>520:</span> <span class='c'>                    // Is it a "standard" option ?</span>
<span class='n'>521:</span> <span class='e'>                    if (    ! strcmp(argv[i],"-version")</span>
<span class='n'>522:</span> <span class='e'>                         || ! strncmp(argv[i],"V",1)) {</span>
<span class='n'>523:</span> <span class='e'>                        printf ("%s %s\n",LOGO,VERSION);</span>
<span class='n'>524:</span> <span class='e'>                        exit (EXIT_SUCCESS);</span>
<span class='n'>525:</span> <span class='e'>                    } else if (   ! strcmp(argv[i],"h")</span>
<span class='n'>526:</span> <span class='e'>                               || ! strcmp(argv[i],"-help")</span>
<span class='n'>527:</span> <span class='e'>                               || ! strncmp(argv[i],"?",1)) {</span>
<span class='n'>528:</span> <span class='e'>                        info (stdout);                  //  Print info and exit</span>
<span class='n'>529:</span> <span class='c'>                    }</span>
<span class='n'>530:</span> <span class='c'>                    // Option argument not found in option list</span>
<span class='n'>531:</span> <span class='c'>                    // Print error message, info, and terminate program</span>
<span class='n'>532:</span> <span class='e'>                    fprintf (stderr, "\n"LOGO": Unknown option -%s\n\n", argv[i]);</span>
<span class='n'>533:</span> <span class='e'>                    info (stderr);</span>
<span class='n'>534:</span> <span class='c'>                }</span>
<span class='n'>535:</span> <span class='c'>            }</span>
<span class='n'>536:</span> <span class='c'>        } else {</span>
<span class='n'>537:</span> <span class='c'>            // Print error message, info, and terminate program</span>
<span class='n'>538:</span> <span class='e'>            fprintf (stderr, "\n"LOGO": Unknown argument %s\n\n", argv[i]);</span>
<span class='n'>539:</span> <span class='e'>            info (stderr);</span>
<span class='n'>540:</span> <span class='c'>        }</span>
<span class='n'>541:</span> <span class='c'>    }</span>
<span class='n'>542:</span> <span class='c'></span>
<span class='n'>543:</span> <span class='e'>    if (verbose &gt; 0) {</span>
<span class='n'>544:</span> <span class='e'>        fprintf (stderr, "Number of points %d\n", n);</span>
<span class='n'>545:</span> <span class='e'>        if (inv) {</span>
<span class='n'>546:</span> <span class='e'>            fprintf (stderr,"Generating code for inverse FFT\n");</span>
<span class='n'>547:</span> <span class='c'>        } else {</span>
<span class='n'>548:</span> <span class='e'>            fprintf (stderr,"Generating code for standard (not inverse) FFT\n");</span>
<span class='n'>549:</span> <span class='c'>        }</span>
<span class='n'>550:</span> <span class='e'>        if (realIn) {</span>
<span class='n'>551:</span> <span class='e'>            fprintf (stderr,"Optimize for real only input\n");</span>
<span class='n'>552:</span> <span class='c'>        }</span>
<span class='n'>553:</span> <span class='e'>        if (realOut) {</span>
<span class='n'>554:</span> <span class='e'>            fprintf (stderr,"Optimize for real only output\n");</span>
<span class='n'>555:</span> <span class='c'>        }</span>
<span class='n'>556:</span> <span class='e'>        if (symmIn) {</span>
<span class='n'>557:</span> <span class='e'>            fprintf (stderr,"Optimize for symmetry at input\n");</span>
<span class='n'>558:</span> <span class='c'>        }</span>
<span class='n'>559:</span> <span class='e'>        if (symmOut) {</span>
<span class='n'>560:</span> <span class='e'>            fprintf (stderr,"Optimize for symmetry at output\n");</span>
<span class='n'>561:</span> <span class='c'>        }</span>
<span class='n'>562:</span> <span class='e'>        if (license) {</span>
<span class='n'>563:</span> <span class='e'>            fprintf (stderr,"Include a GPL 3 note into the code\n");</span>
<span class='n'>564:</span> <span class='c'>        }</span>
<span class='n'>565:</span> <span class='c'>    }</span>
<span class='n'>566:</span> <span class='e'>    if (n == 0) {</span>
<span class='n'>567:</span> <span class='e'>        fprintf (stderr,"\n"LOGO": No number of points specified.\n");</span>
<span class='n'>568:</span> <span class='e'>        info (stderr);</span>
<span class='n'>569:</span> <span class='c'>    }</span>
<span class='n'>570:</span> <span class='e'>    if (n &amp; (n-1)) {    // Check n is not a power of two</span>
<span class='n'>571:</span> <span class='e'>        fprintf (stderr,"\n"LOGO": Number of points %d is not a power of two.\n", n);</span>
<span class='n'>572:</span> <span class='e'>        info (stderr);</span>
<span class='n'>573:</span> <span class='c'>    }</span>
<span class='n'>574:</span> <span class='c'></span>
<span class='n'>575:</span> <span class='e'>    if (license)  fputs (licenseText, stdout);</span>
<span class='n'>576:</span> <span class='e'>    fputs (header, stdout);</span>
<span class='n'>577:</span> <span class='c'></span>
<span class='n'>578:</span> <span class='e'>    fftGen (n,inv,realIn, realOut, symmIn, symmOut);</span>
<span class='n'>579:</span> <span class='c'></span>
<span class='n'>580:</span> <span class='e'>    fputs (footer, stdout);</span>
<span class='n'>581:</span> <span class='c'></span>
<span class='n'>582:</span> <span class='e'>    return  EXIT_SUCCESS;</span>
<span class='n'>583:</span> <span class='c'>}</span>
<span class='n'>584:</span> <span class='c'></span>
<span class='n'>585:</span> <span class='c'></span>
<span class='n'>586:</span> <span class='c'></span>
<span class='n'>587:</span> <span class='c'>//==============================================================================</span>
<span class='n'>588:</span> <span class='c'>// Code generating function</span>
<span class='n'>589:</span> <span class='c'>//</span>
<span class='n'>590:</span> <span class='c'></span>
<span class='n'>591:</span> <span class='e'>static void  fftGen (</span>
<span class='n'>592:</span> <span class='c'>    const int  n,             // Number of points</span>
<span class='n'>593:</span> <span class='c'>    const int  inv,           // Flag: !=0: inverse FFT</span>
<span class='n'>594:</span> <span class='c'>    const int  realIn,        // Flag: !=0: Optimize for real only input</span>
<span class='n'>595:</span> <span class='c'>    const int  realOut,       // Flag: !=0: Optimize for real only output</span>
<span class='n'>596:</span> <span class='c'>    const int  symmIn,        // Flag: !=0: Optimize for symmetry at input</span>
<span class='n'>597:</span> <span class='c'>    const int  symmOut        // Flag: !=0: Optimize for symmetry at output</span>
<span class='n'>598:</span> <span class='c'>) {</span>
<span class='n'>599:</span> <span class='c'>#define  LINELEN   200</span>
<span class='n'>600:</span> <span class='c'>    static char  line[LINELEN];</span>
<span class='n'>601:</span> <span class='c'></span>
<span class='n'>602:</span> <span class='c'>    int     nm,mr,nn,m,k,istep,i,ii,jj;</span>
<span class='n'>603:</span> <span class='c'>    double  a,wr,wi;</span>
<span class='n'>604:</span> <span class='c'></span>
<span class='n'>605:</span> <span class='e'>    const double  eps = 0.5*sin(M_PI/(n/2));</span>
<span class='n'>606:</span> <span class='e'>    const double  epsOne  =  1.0 - 0.5*(1.0-cos(M_PI/(n/2)));</span>
<span class='n'>607:</span> <span class='e'>    const double  epsMOne = -1.0 + 0.5*(1.0-cos(M_PI/(n/2)));</span>
<span class='n'>608:</span> <span class='c'></span>
<span class='n'>609:</span> <span class='e'>    int  lastKCycle = 0;</span>
<span class='n'>610:</span> <span class='c'></span>
<span class='n'>611:</span> <span class='c'>    typedef</span>
<span class='n'>612:</span> <span class='c'>        struct SwapSt {</span>
<span class='n'>613:</span> <span class='c'>            int  m;         // m and mr will have to be swapped</span>
<span class='n'>614:</span> <span class='c'>            int  mr;</span>
<span class='n'>615:</span> <span class='c'>            int  m_new;     // m value to be used for the source of the</span>
<span class='n'>616:</span> <span class='c'>                            // assignment insted of m at symmIn</span>
<span class='n'>617:</span> <span class='c'>            int  mr_new;    // mr value to be used for the source of the</span>
<span class='n'>618:</span> <span class='c'>                            // assignment insted of mr at symmIn</span>
<span class='n'>619:</span> <span class='c'>            int  symmIn;    // Flag: Use the input symmetry relationship for</span>
<span class='n'>620:</span> <span class='c'>                            // this element</span>
<span class='n'>621:</span> <span class='c'>        } SWAP;</span>
<span class='n'>622:</span> <span class='c'>    SWAP  *swap;</span>
<span class='n'>623:</span> <span class='c'>    int  nSwap;             // Number of swap commands in array swap[]</span>
<span class='n'>624:</span> <span class='c'></span>
<span class='n'>625:</span> <span class='c'>    // To keep track of xi[i] being zero at realIn optimization.</span>
<span class='n'>626:</span> <span class='c'>    // If xi[i]!=0 then nz[i]==1.</span>
<span class='n'>627:</span> <span class='e'>    int  *nzi = (int*)malloc (sizeof(int)*n);</span>
<span class='n'>628:</span> <span class='e'>    if (nzi == NULL) {</span>
<span class='n'>629:</span> <span class='u'>        fprintf (stderr, "\n"LOGO": Error allocating memory: %s\n", strerror(errno));</span>
<span class='n'>630:</span> <span class='u'>        exit (EXIT_FAILURE);</span>
<span class='n'>631:</span> <span class='c'>    }</span>
<span class='n'>632:</span> <span class='c'></span>
<span class='n'>633:</span> <span class='e'>    if ( ! realIn) {</span>
<span class='n'>634:</span> <span class='e'>        for (i=0; i&lt;n; ++i)  nzi[i] = 1;</span>
<span class='n'>635:</span> <span class='c'>    } else {</span>
<span class='n'>636:</span> <span class='e'>        for (i=0; i&lt;n; ++i)  nzi[i] = 0;</span>
<span class='n'>637:</span> <span class='c'>    }</span>
<span class='n'>638:</span> <span class='c'></span>
<span class='n'>639:</span> <span class='e'>    nn = n-1;</span>
<span class='n'>640:</span> <span class='c'></span>
<span class='n'>641:</span> <span class='c'>    //==========================================================================</span>
<span class='n'>642:</span> <span class='c'>    // Implement the binary inversion algorithm</span>
<span class='n'>643:</span> <span class='c'></span>
<span class='n'>644:</span> <span class='c'>    // 1) Create the array swap[] to store the swapping commands to be conducted</span>
<span class='n'>645:</span> <span class='c'>    //    later.</span>
<span class='n'>646:</span> <span class='c'>    // 2) Fill it with the swapping commands of the binary inversion algorithm.</span>
<span class='n'>647:</span> <span class='c'>    // 3) In case of symmIn create new source indices mr_new according to the</span>
<span class='n'>648:</span> <span class='c'>    //    symmetry relationship x[m]=x*[mr_new=n-mr] (x* being the conjugate</span>
<span class='n'>649:</span> <span class='c'>    //    complex value) if mr &gt; n/2.</span>
<span class='n'>650:</span> <span class='c'>    // 4) Check whether the new source index mr_new would have been overwritten</span>
<span class='n'>651:</span> <span class='c'>    //    already before the current swapping.</span>
<span class='n'>652:</span> <span class='c'>    //    - In that case insert the current swap command in the list before the</span>
<span class='n'>653:</span> <span class='c'>    //      one which would overwrite mr_new.</span>
<span class='n'>654:</span> <span class='c'>    // 5) Conduct the swapping commands in the order as now found in the array.</span>
<span class='n'>655:</span> <span class='c'></span>
<span class='n'>656:</span> <span class='e'>    swap = (SWAP*)malloc (sizeof(SWAP)*n);</span>
<span class='n'>657:</span> <span class='e'>    if (swap == NULL) {</span>
<span class='n'>658:</span> <span class='u'>        fprintf (stderr, "\n"LOGO": Error allocating memory: %s\n", strerror(errno));</span>
<span class='n'>659:</span> <span class='u'>        exit (EXIT_FAILURE);</span>
<span class='n'>660:</span> <span class='c'>    }</span>
<span class='n'>661:</span> <span class='e'>    for (i=0; i&lt;n; ++i) {</span>
<span class='n'>662:</span> <span class='e'>        swap[i].m = 0;</span>
<span class='n'>663:</span> <span class='e'>        swap[i].mr = 0;</span>
<span class='n'>664:</span> <span class='e'>        swap[i].m_new = 0;</span>
<span class='n'>665:</span> <span class='e'>        swap[i].mr_new = 0;</span>
<span class='n'>666:</span> <span class='c'>    }</span>
<span class='n'>667:</span> <span class='c'></span>
<span class='n'>668:</span> <span class='c'>    //--------------------------------------------------------------------------</span>
<span class='n'>669:</span> <span class='c'>    // Fill swap[] with the binary inversion swap commands and order the</span>
<span class='n'>670:</span> <span class='c'>    // elements such that if the symmetry relationship is to be used the source</span>
<span class='n'>671:</span> <span class='c'>    // elements are not overwritten</span>
<span class='n'>672:</span> <span class='c'></span>
<span class='n'>673:</span> <span class='e'>    mr = 0;</span>
<span class='n'>674:</span> <span class='e'>    for (nSwap=0,m=1; m&lt;=nn; ++m) {</span>
<span class='n'>675:</span> <span class='e'>        k = n;</span>
<span class='n'>676:</span> <span class='c'>        do {</span>
<span class='n'>677:</span> <span class='e'>            k /= 2;</span>
<span class='n'>678:</span> <span class='e'>        } while (mr+k &gt; nn);</span>
<span class='n'>679:</span> <span class='e'>        mr = mr%k + k;</span>
<span class='n'>680:</span> <span class='c'></span>
<span class='n'>681:</span> <span class='c'>        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>682:</span> <span class='c'>        // Prepare implementation of "if (mr &gt; m)  SWAP(x[m],x[mr]);"</span>
<span class='n'>683:</span> <span class='c'></span>
<span class='n'>684:</span> <span class='c'>                    // nSwap is the index of the current swap command in swap[]</span>
<span class='n'>685:</span> <span class='e'>        if (mr &gt; m) {</span>
<span class='n'>686:</span> <span class='e'>            if ( ! symmIn) {</span>
<span class='n'>687:</span> <span class='e'>                swap[nSwap].m = m;             // Swapping according to standard</span>
<span class='n'>688:</span> <span class='e'>                swap[nSwap].mr = mr;           //    binary inversion algorithm</span>
<span class='n'>689:</span> <span class='e'>                swap[nSwap].symmIn = 0;</span>
<span class='n'>690:</span> <span class='c'>            } else {</span>
<span class='n'>691:</span> <span class='c'>                // Optimize assuming input symmetry</span>
<span class='n'>692:</span> <span class='e'>                swap[nSwap].m = m;</span>
<span class='n'>693:</span> <span class='e'>                swap[nSwap].mr = mr;</span>
<span class='n'>694:</span> <span class='c'></span>
<span class='n'>695:</span> <span class='e'>                if (m&lt;=n/2 &amp;&amp; mr&lt;=n/2) {</span>
<span class='n'>696:</span> <span class='e'>                    swap[nSwap].symmIn = 0;       // No symmetry subst. required</span>
<span class='n'>697:</span> <span class='c'>                } else {</span>
<span class='n'>698:</span> <span class='e'>                    int  i_m  = 0;</span>
<span class='n'>699:</span> <span class='e'>                    int  i_mr = 0;</span>
<span class='n'>700:</span> <span class='e'>                    int  m_new = m;</span>
<span class='n'>701:</span> <span class='e'>                    int  mr_new = mr;</span>
<span class='n'>702:</span> <span class='c'></span>
<span class='n'>703:</span> <span class='e'>                    if (m  &gt; n/2)  m_new  = n - m ; // Use symmetry relationship</span>
<span class='n'>704:</span> <span class='e'>                    if (mr &gt; n/2)  mr_new = n - mr; //  "</span>
<span class='n'>705:</span> <span class='c'></span>
<span class='n'>706:</span> <span class='e'>                    swap[nSwap].m_new = m_new;</span>
<span class='n'>707:</span> <span class='e'>                    swap[nSwap].mr_new = mr_new;</span>
<span class='n'>708:</span> <span class='e'>                    swap[nSwap].symmIn = 1;</span>
<span class='n'>709:</span> <span class='c'></span>
<span class='n'>710:</span> <span class='c'>                    // Check whether the array element at the new mr (mr_new)</span>
<span class='n'>711:</span> <span class='c'>                    // would have been assigned already</span>
<span class='n'>712:</span> <span class='c'></span>
<span class='n'>713:</span> <span class='e'>                    if (m &gt; n/2) {</span>
<span class='n'>714:</span> <span class='c'>                        // Check whether m_new would have been overwritten by a</span>
<span class='n'>715:</span> <span class='c'>                        // writing to element with index m or mr</span>
<span class='n'>716:</span> <span class='e'>                        for (i_m=nSwap-1; i_m&gt;0; --i_m) {</span>
<span class='n'>717:</span> <span class='e'>                            if (m_new == swap[i_m].m || m_new == swap[i_m].mr)  break;</span>
<span class='n'>718:</span> <span class='c'>                        }</span>
<span class='n'>719:</span> <span class='c'>                    }</span>
<span class='n'>720:</span> <span class='e'>                    if (mr &gt; n/2) {</span>
<span class='n'>721:</span> <span class='c'>                        // Check whether mr_new would have been overwritten by a</span>
<span class='n'>722:</span> <span class='c'>                        // writing to element with index m or mr</span>
<span class='n'>723:</span> <span class='e'>                        for (i_mr=nSwap-1; i_mr&gt;0; --i_mr) {</span>
<span class='n'>724:</span> <span class='e'>                            if (mr_new == swap[i_mr].m || mr_new == swap[i_mr].mr)  break;</span>
<span class='n'>725:</span> <span class='c'>                        }</span>
<span class='n'>726:</span> <span class='c'>                    }</span>
<span class='n'>727:</span> <span class='c'></span>
<span class='n'>728:</span> <span class='c'>                    // Use the lowest of both and assign it to i_mr</span>
<span class='n'>729:</span> <span class='e'>                    if (i_mr&gt;0 &amp;&amp; i_m&gt;0) {</span>
<span class='n'>730:</span> <span class='e'>                        if (i_mr&gt;i_m)  i_mr = i_m;</span>
<span class='n'>731:</span> <span class='e'>                    } else if (i_m&gt;0) {</span>
<span class='n'>732:</span> <span class='u'>                        i_mr = i_m;</span>
<span class='n'>733:</span> <span class='c'>                    }</span>
<span class='n'>734:</span> <span class='c'></span>
<span class='n'>735:</span> <span class='c'>                    // If the search ended successfully (i.e. before reaching 0)</span>
<span class='n'>736:</span> <span class='e'>                    if (i_mr &gt; 0) {</span>
<span class='n'>737:</span> <span class='c'>                        // The array element at mr_new would have been assigned</span>
<span class='n'>738:</span> <span class='c'>                        // already.</span>
<span class='n'>739:</span> <span class='c'>                        // Create space in array swap[] at index i_mr, firstly</span>
<span class='n'>740:</span> <span class='c'>                        // overwriting swap[nSwap]</span>
<span class='n'>741:</span> <span class='e'>                        for (ii=nSwap; ii&gt;i_mr; --ii) {</span>
<span class='n'>742:</span> <span class='e'>                            swap[ii].m      = swap[ii-1].m ;</span>
<span class='n'>743:</span> <span class='e'>                            swap[ii].mr     = swap[ii-1].mr;</span>
<span class='n'>744:</span> <span class='e'>                            swap[ii].m_new  = swap[ii-1].m_new;</span>
<span class='n'>745:</span> <span class='e'>                            swap[ii].mr_new = swap[ii-1].mr_new;</span>
<span class='n'>746:</span> <span class='e'>                            swap[ii].symmIn = swap[ii-1].symmIn;</span>
<span class='n'>747:</span> <span class='c'>                        }</span>
<span class='n'>748:</span> <span class='c'>                        // Insert the new swap command at index ii, i.e.</span>
<span class='n'>749:</span> <span class='c'>                        // before the command that would overwrite mr</span>
<span class='n'>750:</span> <span class='e'>                        swap[i_mr].m = m;</span>
<span class='n'>751:</span> <span class='e'>                        swap[i_mr].mr = mr;</span>
<span class='n'>752:</span> <span class='e'>                        swap[i_mr].m_new = m_new;</span>
<span class='n'>753:</span> <span class='e'>                        swap[i_mr].mr_new = mr_new;</span>
<span class='n'>754:</span> <span class='e'>                        swap[i_mr].symmIn = 1;</span>
<span class='n'>755:</span> <span class='c'>                    }</span>
<span class='n'>756:</span> <span class='c'>                }</span>
<span class='n'>757:</span> <span class='c'>            }</span>
<span class='n'>758:</span> <span class='e'>            ++nSwap;</span>
<span class='n'>759:</span> <span class='c'>        }</span>
<span class='n'>760:</span> <span class='c'>    }</span>
<span class='n'>761:</span> <span class='e'>    if (symmIn) {</span>
<span class='n'>762:</span> <span class='c'>        // When optimizing assuming input symmetry then</span>
<span class='n'>763:</span> <span class='c'>        //   check whether there are indices not yet considered.</span>
<span class='n'>764:</span> <span class='c'>        // Therefore, check swap[] for not listed indices from n/2+1 onwards.</span>
<span class='n'>765:</span> <span class='c'>        // Consider the symmetry relationship for those now.</span>
<span class='n'>766:</span> <span class='c'>        // Note: This must be done before conducting the binary inversion</span>
<span class='n'>767:</span> <span class='c'>        // algorithm because that will overwrite the elements with according</span>
<span class='n'>768:</span> <span class='c'>        // indices.</span>
<span class='n'>769:</span> <span class='e'>        for (i=n/2+1; i&lt;n; ++i) {</span>
<span class='n'>770:</span> <span class='e'>            for (ii=nSwap-1; ii&gt;=0; --ii) {</span>
<span class='n'>771:</span> <span class='e'>                if (swap[ii].m==i || swap[ii].mr==i)  break;</span>
<span class='n'>772:</span> <span class='c'>            }</span>
<span class='n'>773:</span> <span class='e'>            if (ii &lt; 0) {   // i not listed in swap[]</span>
<span class='n'>774:</span> <span class='e'>                printf (INDENT"xr[%d] =  xr[%d];\n", i, n - i);</span>
<span class='n'>775:</span> <span class='e'>                printf (INDENT"xi[%d] = -xi[%d];\n", i, n - i);</span>
<span class='n'>776:</span> <span class='c'>            }</span>
<span class='n'>777:</span> <span class='c'>        }</span>
<span class='n'>778:</span> <span class='c'>    }</span>
<span class='n'>779:</span> <span class='c'></span>
<span class='n'>780:</span> <span class='c'>    //--------------------------------------------------------------------------</span>
<span class='n'>781:</span> <span class='c'>    // Conduct swapping</span>
<span class='n'>782:</span> <span class='c'></span>
<span class='n'>783:</span> <span class='e'>    for (k=0; k&lt;nSwap; ++k) {</span>
<span class='n'>784:</span> <span class='c'>        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>785:</span> <span class='c'>        // Implement  "if (mr &gt; m)  SWAP(x[m],x[mr]);"</span>
<span class='n'>786:</span> <span class='e'>        if ( ! swap[k].symmIn) {</span>
<span class='n'>787:</span> <span class='c'>            // Swapping according to standard binary inversion algorithm</span>
<span class='n'>788:</span> <span class='e'>            printf (INDENT"tr = xr[%d];\n", swap[k].m);</span>
<span class='n'>789:</span> <span class='e'>            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].m, swap[k].mr);</span>
<span class='n'>790:</span> <span class='e'>            printf (INDENT"xr[%d] = tr;\n", swap[k].mr);</span>
<span class='n'>791:</span> <span class='e'>            if ( ! realIn) {</span>
<span class='n'>792:</span> <span class='e'>                printf (INDENT"ti = xi[%d];\n", swap[k].m);</span>
<span class='n'>793:</span> <span class='e'>                printf (INDENT"xi[%d] = xi[%d];\n", swap[k].m, swap[k].mr);</span>
<span class='n'>794:</span> <span class='e'>                printf (INDENT"xi[%d] = ti;\n", swap[k].mr);</span>
<span class='n'>795:</span> <span class='c'>            }</span>
<span class='n'>796:</span> <span class='c'>        } else {</span>
<span class='n'>797:</span> <span class='c'>            // Use the conjugate complex value of (xr[n-mr],xi[n-mr]) but only</span>
<span class='n'>798:</span> <span class='c'>            // if the source index of the assignment would have been &gt;n/2</span>
<span class='n'>799:</span> <span class='e'>            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].mr, swap[k].m_new);</span>
<span class='n'>800:</span> <span class='e'>            printf (INDENT"xr[%d] = xr[%d];\n", swap[k].m, swap[k].mr_new);</span>
<span class='n'>801:</span> <span class='e'>            if ( ! realIn) {</span>
<span class='n'>802:</span> <span class='e'>                if (swap[k].m &lt;= n/2) {</span>
<span class='n'>803:</span> <span class='e'>                    printf (INDENT"xi[%d] = xi[%d];\n", swap[k].mr, swap[k].m_new);</span>
<span class='n'>804:</span> <span class='c'>                } else {</span>
<span class='n'>805:</span> <span class='c'>                    // Negating xi for the conjugate complex value is required</span>
<span class='n'>806:</span> <span class='e'>                    printf (INDENT"xi[%d] = -xi[%d];\n", swap[k].mr, swap[k].m_new);</span>
<span class='n'>807:</span> <span class='c'>                }</span>
<span class='n'>808:</span> <span class='e'>                if (swap[k].mr &lt;= n/2) {</span>
<span class='n'>809:</span> <span class='u'>                    printf (INDENT"xi[%d] = xi[%d];\n", swap[k].m, swap[k].mr_new);</span>
<span class='n'>810:</span> <span class='c'>                } else {</span>
<span class='n'>811:</span> <span class='c'>                    // Negating xi for the conjugate complex value is required</span>
<span class='n'>812:</span> <span class='e'>                    printf (INDENT"xi[%d] = -xi[%d];\n", swap[k].m, swap[k].mr_new);</span>
<span class='n'>813:</span> <span class='c'>                }</span>
<span class='n'>814:</span> <span class='c'>            }</span>
<span class='n'>815:</span> <span class='c'>        }</span>
<span class='n'>816:</span> <span class='c'>    }</span>
<span class='n'>817:</span> <span class='e'>    putchar ('\n');</span>
<span class='n'>818:</span> <span class='c'></span>
<span class='n'>819:</span> <span class='c'>    //==========================================================================</span>
<span class='n'>820:</span> <span class='c'>    // Do the transform</span>
<span class='n'>821:</span> <span class='c'></span>
<span class='n'>822:</span> <span class='e'>    for (k=1; k&lt;n; k=istep) {</span>
<span class='n'>823:</span> <span class='e'>        istep = 2*k;</span>
<span class='n'>824:</span> <span class='e'>        if (istep==n)  lastKCycle = 1;</span>
<span class='n'>825:</span> <span class='c'></span>
<span class='n'>826:</span> <span class='e'>        for (m=0; m&lt;k; ++m) {</span>
<span class='n'>827:</span> <span class='e'>            a  = M_PI*(-m)/k;</span>
<span class='n'>828:</span> <span class='e'>            wr = cos (a);</span>
<span class='n'>829:</span> <span class='e'>            wi = sin (a);</span>
<span class='n'>830:</span> <span class='e'>            if (inv)  wi = -wi;     // Prepare inverse FFT</span>
<span class='n'>831:</span> <span class='e'>            ii = m;</span>
<span class='n'>832:</span> <span class='e'>            nm = (nn-m)/istep + m;</span>
<span class='n'>833:</span> <span class='e'>            for (i=m; i&lt;=nm; ++i) {</span>
<span class='n'>834:</span> <span class='c'>                size_t  len;</span>
<span class='n'>835:</span> <span class='c'>                               // Flag: 1st summand of</span>
<span class='n'>836:</span> <span class='c'>                               //   tr = wr*xr[jj] - wi*xi[jj];</span>
<span class='n'>837:</span> <span class='c'>                               // or</span>
<span class='n'>838:</span> <span class='c'>                               //   ti = wr*xi[jj] + wi*xr[jj];</span>
<span class='n'>839:</span> <span class='c'>                               // is zero</span>
<span class='n'>840:</span> <span class='c'>                int  firstOpZero;</span>
<span class='n'>841:</span> <span class='e'>                int  trz = 0;  // Flag: Expression tr=wr*xr[jj]-wi*xi[jj] == 0</span>
<span class='n'>842:</span> <span class='e'>                int  tiz = 0;  // Flag: Expression ti=wr*xi[jj]+wi*xr[jj] == 0</span>
<span class='n'>843:</span> <span class='c'></span>
<span class='n'>844:</span> <span class='e'>                jj = ii+k;</span>
<span class='n'>845:</span> <span class='c'></span>
<span class='n'>846:</span> <span class='c'>#ifndef OPTIMIZE_SINE_COSINE_VALUES</span>
<span class='n'>847:</span> <span class='c'>                printf (INDENT"tr = "NUMBER_FORMAT"*xr[%d] - "NUMBER_FORMAT"*xi[%d];\n", wr, jj, wi, jj);</span>
<span class='n'>848:</span> <span class='c'>                printf (INDENT"ti = "NUMBER_FORMAT"*xi[%d] + "NUMBER_FORMAT"*xr[%d];\n", wr, jj, wi, jj);</span>
<span class='n'>849:</span> <span class='c'>#else</span>
<span class='n'>850:</span> <span class='c'>                //--------------------------------------------------------------</span>
<span class='n'>851:</span> <span class='c'>                // Implement tr = wr*xr[jj] - wi*xi[jj];</span>
<span class='n'>852:</span> <span class='c'></span>
<span class='n'>853:</span> <span class='c'>                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>854:</span> <span class='c'>                // Part wr*xr[jj]</span>
<span class='n'>855:</span> <span class='e'>                firstOpZero = 0;</span>
<span class='n'>856:</span> <span class='c'></span>
<span class='n'>857:</span> <span class='e'>                snprintf (line, LINELEN, INDENT"tr =");</span>
<span class='n'>858:</span> <span class='e'>                len = strlen (line);</span>
<span class='n'>859:</span> <span class='c'></span>
<span class='n'>860:</span> <span class='e'>                if (fabs(wr) &gt; eps) {</span>
<span class='n'>861:</span> <span class='c'>                    // wr != 0</span>
<span class='n'>862:</span> <span class='e'>                    if (wr &lt; epsOne) {</span>
<span class='n'>863:</span> <span class='c'>                        // wr != 1</span>
<span class='n'>864:</span> <span class='e'>                        if (wr &gt; epsMOne) {</span>
<span class='n'>865:</span> <span class='c'>                            // wr != -1</span>
<span class='n'>866:</span> <span class='e'>                            snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xr[%d]", wr, jj);</span>
<span class='n'>867:</span> <span class='c'>                        } else {</span>
<span class='n'>868:</span> <span class='c'>                            // wr == -1</span>
<span class='n'>869:</span> <span class='u'>                            snprintf (line+len,LINELEN-len," -xr[%d]", jj);</span>
<span class='n'>870:</span> <span class='c'>                        }</span>
<span class='n'>871:</span> <span class='c'>                    } else {</span>
<span class='n'>872:</span> <span class='c'>                        // wr == 1</span>
<span class='n'>873:</span> <span class='e'>                        snprintf (line+len,LINELEN-len," xr[%d]", jj);</span>
<span class='n'>874:</span> <span class='c'>                    }</span>
<span class='n'>875:</span> <span class='c'>                } else {</span>
<span class='n'>876:</span> <span class='e'>                    firstOpZero = 1;</span>
<span class='n'>877:</span> <span class='c'>                }</span>
<span class='n'>878:</span> <span class='e'>                len = strlen (line);</span>
<span class='n'>879:</span> <span class='c'></span>
<span class='n'>880:</span> <span class='c'>                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>881:</span> <span class='c'>                // Part -wi*xi[jj]</span>
<span class='n'>882:</span> <span class='c'></span>
<span class='n'>883:</span> <span class='e'>                trz = 0;</span>
<span class='n'>884:</span> <span class='e'>                if (fabs(wi) &gt; eps  &amp;&amp;  nzi[jj]) {</span>
<span class='n'>885:</span> <span class='c'>                    // wi != 0  and  xi[jj] non-zero</span>
<span class='n'>886:</span> <span class='e'>                    if (wi &lt; epsOne) {</span>
<span class='n'>887:</span> <span class='c'>                        // wi != 1</span>
<span class='n'>888:</span> <span class='e'>                        if (wi &gt; epsMOne) {</span>
<span class='n'>889:</span> <span class='c'>                            // wi != -1</span>
<span class='n'>890:</span> <span class='e'>                            if ( ! firstOpZero) {       // If wr*xr[jj] != 0</span>
<span class='n'>891:</span> <span class='e'>                                if (wi &gt;= 0.0) {</span>
<span class='n'>892:</span> <span class='e'>                                    snprintf (line+len,LINELEN-len," - "NUMBER_FORMAT"*xi[%d]", wi, jj);</span>
<span class='n'>893:</span> <span class='c'>                                } else {</span>
<span class='n'>894:</span> <span class='e'>                                    snprintf (line+len,LINELEN-len," + "NUMBER_FORMAT"*xi[%d]", -wi, jj);</span>
<span class='n'>895:</span> <span class='c'>                                }</span>
<span class='n'>896:</span> <span class='c'>                            } else {</span>
<span class='n'>897:</span> <span class='u'>                                snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xi[%d]", -wi, jj);</span>
<span class='n'>898:</span> <span class='c'>                            }</span>
<span class='n'>899:</span> <span class='c'>                        } else {</span>
<span class='n'>900:</span> <span class='c'>                            // wi == -1</span>
<span class='n'>901:</span> <span class='e'>                            if ( ! firstOpZero) {</span>
<span class='n'>902:</span> <span class='u'>                                snprintf (line+len,LINELEN-len," + xi[%d]", jj);</span>
<span class='n'>903:</span> <span class='c'>                            } else {</span>
<span class='n'>904:</span> <span class='e'>                                snprintf (line+len,LINELEN-len," xi[%d]", jj);</span>
<span class='n'>905:</span> <span class='c'>                            }</span>
<span class='n'>906:</span> <span class='c'>                        }</span>
<span class='n'>907:</span> <span class='c'>                    } else {</span>
<span class='n'>908:</span> <span class='c'>                        // wi == 1</span>
<span class='n'>909:</span> <span class='e'>                        snprintf (line+len,LINELEN-len," - xi[%d]", jj);</span>
<span class='n'>910:</span> <span class='c'>                    }</span>
<span class='n'>911:</span> <span class='e'>                    fputs (line, stdout);</span>
<span class='n'>912:</span> <span class='e'>                    fputs (";\n", stdout);</span>
<span class='n'>913:</span> <span class='c'>                } else {</span>
<span class='n'>914:</span> <span class='c'>                    // wr == 0  or  xi[jj] == 0</span>
<span class='n'>915:</span> <span class='e'>                    if ( ! firstOpZero) {</span>
<span class='n'>916:</span> <span class='e'>                        fputs (line, stdout);</span>
<span class='n'>917:</span> <span class='e'>                        fputs (";\n", stdout);</span>
<span class='n'>918:</span> <span class='c'>                    } else {</span>
<span class='n'>919:</span> <span class='e'>                        trz = 1;    // tr = wr*xr[jj]-wi*xi[jj] == 0</span>
<span class='n'>920:</span> <span class='c'>                        // Expression for tr is zero, so don't write anything</span>
<span class='n'>921:</span> <span class='c'>                    }</span>
<span class='n'>922:</span> <span class='c'>                }</span>
<span class='n'>923:</span> <span class='c'></span>
<span class='n'>924:</span> <span class='c'>                //--------------------------------------------------------------</span>
<span class='n'>925:</span> <span class='c'>                // Implement ti = wr*xi[jj] + wi*xr[jj];</span>
<span class='n'>926:</span> <span class='c'></span>
<span class='n'>927:</span> <span class='e'>                if ( ! (realOut &amp;&amp; lastKCycle)) {</span>
<span class='n'>928:</span> <span class='c'></span>
<span class='n'>929:</span> <span class='c'>                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>930:</span> <span class='c'>                    // Part wr*xi[jj]</span>
<span class='n'>931:</span> <span class='c'></span>
<span class='n'>932:</span> <span class='e'>                    firstOpZero = 0;</span>
<span class='n'>933:</span> <span class='e'>                    snprintf (line, LINELEN, INDENT"ti =");</span>
<span class='n'>934:</span> <span class='e'>                    len = strlen (line);</span>
<span class='n'>935:</span> <span class='c'></span>
<span class='n'>936:</span> <span class='e'>                    if (fabs(wr) &gt; eps  &amp;&amp;  nzi[jj]) {</span>
<span class='n'>937:</span> <span class='c'>                        // wr != 0  and  xi[jj] non-zero</span>
<span class='n'>938:</span> <span class='e'>                        if (wr &lt; epsOne) {</span>
<span class='n'>939:</span> <span class='c'>                            // wr != 1</span>
<span class='n'>940:</span> <span class='e'>                            if (wr &gt; epsMOne) {</span>
<span class='n'>941:</span> <span class='c'>                                // wr != -1</span>
<span class='n'>942:</span> <span class='e'>                                snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xi[%d]", wr, jj);</span>
<span class='n'>943:</span> <span class='c'>                            } else {</span>
<span class='n'>944:</span> <span class='c'>                                // wr == -1</span>
<span class='n'>945:</span> <span class='u'>                                snprintf (line+len,LINELEN-len," -xi[%d]", jj);</span>
<span class='n'>946:</span> <span class='c'>                            }</span>
<span class='n'>947:</span> <span class='c'>                        } else {</span>
<span class='n'>948:</span> <span class='c'>                            // wr == 1</span>
<span class='n'>949:</span> <span class='e'>                            snprintf (line+len,LINELEN-len," xi[%d]", jj);</span>
<span class='n'>950:</span> <span class='c'>                        }</span>
<span class='n'>951:</span> <span class='c'>                    } else {</span>
<span class='n'>952:</span> <span class='e'>                        firstOpZero = 1;</span>
<span class='n'>953:</span> <span class='c'>                    }</span>
<span class='n'>954:</span> <span class='e'>                    len = strlen (line);</span>
<span class='n'>955:</span> <span class='c'></span>
<span class='n'>956:</span> <span class='c'>                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>957:</span> <span class='c'>                    // Part +wi*xr[jj]</span>
<span class='n'>958:</span> <span class='c'></span>
<span class='n'>959:</span> <span class='e'>                    tiz = 0;</span>
<span class='n'>960:</span> <span class='e'>                    if (fabs(wi) &gt; eps) {</span>
<span class='n'>961:</span> <span class='c'>                        // wi != 0</span>
<span class='n'>962:</span> <span class='e'>                        if (wi &lt; epsOne) {</span>
<span class='n'>963:</span> <span class='c'>                            // wi != 1</span>
<span class='n'>964:</span> <span class='e'>                            if (wi &gt; epsMOne) {</span>
<span class='n'>965:</span> <span class='c'>                                // wi != -1</span>
<span class='n'>966:</span> <span class='e'>                                if ( ! firstOpZero) {       // If wr*xr[jj] != 0</span>
<span class='n'>967:</span> <span class='e'>                                    if (wi &gt;= 0.0) {</span>
<span class='n'>968:</span> <span class='e'>                                        snprintf (line+len,LINELEN-len," + "NUMBER_FORMAT"*xr[%d]", wi, jj);</span>
<span class='n'>969:</span> <span class='c'>                                    } else {</span>
<span class='n'>970:</span> <span class='e'>                                        snprintf (line+len,LINELEN-len," - "NUMBER_FORMAT"*xr[%d]", -wi, jj);</span>
<span class='n'>971:</span> <span class='c'>                                    }</span>
<span class='n'>972:</span> <span class='c'>                                } else {</span>
<span class='n'>973:</span> <span class='u'>                                    snprintf (line+len,LINELEN-len," "NUMBER_FORMAT"*xr[%d]", wi, jj);</span>
<span class='n'>974:</span> <span class='c'>                                }</span>
<span class='n'>975:</span> <span class='c'>                            } else {</span>
<span class='n'>976:</span> <span class='c'>                                // wi == -1</span>
<span class='n'>977:</span> <span class='e'>                                snprintf (line+len,LINELEN-len," - xr[%d]", jj);</span>
<span class='n'>978:</span> <span class='c'>                            }</span>
<span class='n'>979:</span> <span class='c'>                        } else {</span>
<span class='n'>980:</span> <span class='c'>                            // wi == 1</span>
<span class='n'>981:</span> <span class='e'>                            snprintf (line+len,LINELEN-len," xr[%d]", jj);</span>
<span class='n'>982:</span> <span class='c'>                        }</span>
<span class='n'>983:</span> <span class='e'>                        fputs (line, stdout);</span>
<span class='n'>984:</span> <span class='e'>                        fputs (";\n", stdout);</span>
<span class='n'>985:</span> <span class='c'>                    } else {</span>
<span class='n'>986:</span> <span class='c'>                        // wi == 0</span>
<span class='n'>987:</span> <span class='e'>                        if ( ! firstOpZero) {      // If wr*xi[jj] != 0</span>
<span class='n'>988:</span> <span class='e'>                            fputs (line, stdout);</span>
<span class='n'>989:</span> <span class='e'>                            fputs (";\n", stdout);</span>
<span class='n'>990:</span> <span class='c'>                        } else {</span>
<span class='n'>991:</span> <span class='e'>                            tiz = 1;    // ti = wr*xi[jj]+wi*xr[jj] == 0</span>
<span class='n'>992:</span> <span class='c'>                            // Expression for tr is zero, so don't write anything</span>
<span class='n'>993:</span> <span class='c'>                        }</span>
<span class='n'>994:</span> <span class='c'>                    }</span>
<span class='n'>995:</span> <span class='c'>                }</span>
<span class='n'>996:</span> <span class='c'>#endif</span>
<span class='n'>997:</span> <span class='e'>                if ( ! (symmOut &amp;&amp; lastKCycle &amp;&amp; jj!=n/2)) {</span>
<span class='n'>998:</span> <span class='c'>                    //----------------------------------------------------------</span>
<span class='n'>999:</span> <span class='c'>                    // Implement xr[jj] = xr[ii] - tr;</span>
<span class='n'>1000:</span> <span class='c'></span>
<span class='n'>1001:</span> <span class='e'>                    if ( ! trz) {</span>
<span class='n'>1002:</span> <span class='e'>                        printf (INDENT"xr[%d] = xr[%d] - tr;\n", jj, ii);</span>
<span class='n'>1003:</span> <span class='c'>                    } else {</span>
<span class='n'>1004:</span> <span class='e'>                        printf (INDENT"xr[%d] = xr[%d];\n", jj, ii);</span>
<span class='n'>1005:</span> <span class='c'>                    }</span>
<span class='n'>1006:</span> <span class='c'></span>
<span class='n'>1007:</span> <span class='c'>                    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>1008:</span> <span class='c'>                    // Implement xi[jj] = xi[ii] - ti;</span>
<span class='n'>1009:</span> <span class='c'></span>
<span class='n'>1010:</span> <span class='e'>                    if ( ! (realOut &amp;&amp; lastKCycle)) {</span>
<span class='n'>1011:</span> <span class='e'>                        if ( ! tiz) {</span>
<span class='n'>1012:</span> <span class='e'>                            if (nzi[ii]) {</span>
<span class='n'>1013:</span> <span class='e'>                                printf (INDENT"xi[%d] = xi[%d] - ti;\n", jj, ii);</span>
<span class='n'>1014:</span> <span class='c'>                            } else {</span>
<span class='n'>1015:</span> <span class='e'>                                printf (INDENT"xi[%d] = - ti;\n", jj);</span>
<span class='n'>1016:</span> <span class='c'>                            }</span>
<span class='n'>1017:</span> <span class='e'>                            nzi[jj] = 1;</span>
<span class='n'>1018:</span> <span class='c'>                        } else {</span>
<span class='n'>1019:</span> <span class='e'>                            if (nzi[ii]) {</span>
<span class='n'>1020:</span> <span class='u'>                                printf (INDENT"xi[%d] = xi[%d];\n", jj, ii);</span>
<span class='n'>1021:</span> <span class='u'>                                nzi[jj] = 1;</span>
<span class='n'>1022:</span> <span class='e'>                            } else if (realIn &amp;&amp; lastKCycle) {</span>
<span class='n'>1023:</span> <span class='c'>                                // In case of realIn this element has not yet</span>
<span class='n'>1024:</span> <span class='c'>                                // been touched. So it must be set zero here</span>
<span class='n'>1025:</span> <span class='c'>                                // because imaginary input values at realIn</span>
<span class='n'>1026:</span> <span class='c'>                                // could be arbitrary but should contain valid</span>
<span class='n'>1027:</span> <span class='c'>                                // values at output</span>
<span class='n'>1028:</span> <span class='e'>                                printf (INDENT"xi[%d] = 0.0;\n", jj);</span>
<span class='n'>1029:</span> <span class='c'>                            }</span>
<span class='n'>1030:</span> <span class='c'>                        }</span>
<span class='n'>1031:</span> <span class='c'>                    }</span>
<span class='n'>1032:</span> <span class='c'>                }</span>
<span class='n'>1033:</span> <span class='c'></span>
<span class='n'>1034:</span> <span class='c'>                //--------------------------------------------------------------</span>
<span class='n'>1035:</span> <span class='c'>                // Implement xr[ii] += tr;</span>
<span class='n'>1036:</span> <span class='c'></span>
<span class='n'>1037:</span> <span class='e'>                if ( ! trz) {</span>
<span class='n'>1038:</span> <span class='e'>                    printf (INDENT"xr[%d] += tr;\n", ii);</span>
<span class='n'>1039:</span> <span class='c'>                }</span>
<span class='n'>1040:</span> <span class='c'></span>
<span class='n'>1041:</span> <span class='c'>                //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class='n'>1042:</span> <span class='c'>                // Implement xi[ii] += ti;</span>
<span class='n'>1043:</span> <span class='c'></span>
<span class='n'>1044:</span> <span class='e'>                if ( ! (realOut &amp;&amp; lastKCycle)) {</span>
<span class='n'>1045:</span> <span class='e'>                    if ( ! tiz) {</span>
<span class='n'>1046:</span> <span class='e'>                        if (nzi[ii]) {</span>
<span class='n'>1047:</span> <span class='e'>                            printf (INDENT"xi[%d] += ti;\n", ii);</span>
<span class='n'>1048:</span> <span class='c'>                        } else {</span>
<span class='n'>1049:</span> <span class='e'>                            printf (INDENT"xi[%d] = ti;\n", ii);</span>
<span class='n'>1050:</span> <span class='e'>                            nzi[ii] = 1;</span>
<span class='n'>1051:</span> <span class='c'>                        }</span>
<span class='n'>1052:</span> <span class='e'>                    } else if (realIn &amp;&amp; lastKCycle) {</span>
<span class='n'>1053:</span> <span class='c'>                        // In case of realIn this element has not yet been</span>
<span class='n'>1054:</span> <span class='c'>                        // touched. So it must be set zero here because</span>
<span class='n'>1055:</span> <span class='c'>                        // imaginary input values at realIn could be arbitrary</span>
<span class='n'>1056:</span> <span class='c'>                        // but should contain valid values at output</span>
<span class='n'>1057:</span> <span class='e'>                        printf (INDENT"xi[%d] = 0.0;\n", ii);</span>
<span class='n'>1058:</span> <span class='c'>                    }</span>
<span class='n'>1059:</span> <span class='c'>                }</span>
<span class='n'>1060:</span> <span class='c'></span>
<span class='n'>1061:</span> <span class='e'>                ii += istep;</span>
<span class='n'>1062:</span> <span class='c'>            }</span>
<span class='n'>1063:</span> <span class='c'>        }</span>
<span class='n'>1064:</span> <span class='c'>    }</span>
<span class='n'>1065:</span> <span class='c'></span>
<span class='n'>1066:</span> <span class='e'>    free (swap);</span>
<span class='n'>1067:</span> <span class='e'>    free (nzi);</span>
<span class='n'>1068:</span> <span class='e'>}</span>
<span class='n'>1069:</span> <span class='c'></span>
<span class='n'>1070:</span> <span class='c'></span>
<span class='n'>1071:</span> <span class='c'></span>
<span class='n'>1072:</span> <span class='c'>//==============================================================================</span>
<span class='n'>1073:</span> <span class='c'>// checkOptions  V1.2</span>
<span class='n'>1074:</span> <span class='c'>//</span>
<span class='n'>1075:</span> <span class='c'>// Checks whether the command line option passed via argv[*pi] can be found in</span>
<span class='n'>1076:</span> <span class='c'>// the option array passed as *pOp.</span>
<span class='n'>1077:</span> <span class='c'>// The last entry of the option array must consist of zeroes to mark the end of</span>
<span class='n'>1078:</span> <span class='c'>// the array.</span>
<span class='n'>1079:</span> <span class='c'>//</span>
<span class='n'>1080:</span> <span class='c'>// If the option passed as argv[*pi] is found in the array the according array</span>
<span class='n'>1081:</span> <span class='c'>// index is returned in *po.</span>
<span class='n'>1082:</span> <span class='c'>// In that case the function returns 1 as return value if the option was a long</span>
<span class='n'>1083:</span> <span class='c'>// option with or without a parameter or -1 if the option was a short option</span>
<span class='n'>1084:</span> <span class='c'>// without a parameter.</span>
<span class='n'>1085:</span> <span class='c'>//</span>
<span class='n'>1086:</span> <span class='c'>// If the passed option could not be fond in the option array then the function</span>
<span class='n'>1087:</span> <span class='c'>// returns zero as return value.</span>
<span class='n'>1088:</span> <span class='c'>//</span>
<span class='n'>1089:</span> <span class='c'></span>
<span class='n'>1090:</span> <span class='e'>static int  checkOptions (</span>
<span class='n'>1091:</span> <span class='c'>    const int           argc,    // No. of command line entries (from main())</span>
<span class='n'>1092:</span> <span class='c'>    const char *const   argv[],  // Command line entries  (from main())</span>
<span class='n'>1093:</span> <span class='c'>          int  *const   pi,      // Ptr to current command line entry index</span>
<span class='n'>1094:</span> <span class='c'>    const OPTION       *pOp,     // Ptr to option array</span>
<span class='n'>1095:</span> <span class='c'>          int  *const   po       // Index into option array</span>
<span class='n'>1096:</span> <span class='c'>) {</span>
<span class='n'>1097:</span> <span class='e'>    int  ret = 0;</span>
<span class='n'>1098:</span> <span class='c'></span>
<span class='n'>1099:</span> <span class='e'>    for (*po=0; pOp-&gt;shOpt; ++pOp,++*po) {</span>
<span class='n'>1100:</span> <span class='e'>        ret = checkOption (argc,argv,pi,pOp);</span>
<span class='n'>1101:</span> <span class='e'>        if (ret != 0)  return ret;</span>
<span class='n'>1102:</span> <span class='c'>    }</span>
<span class='n'>1103:</span> <span class='e'>    return ret;</span>
<span class='n'>1104:</span> <span class='c'>}</span>
<span class='n'>1105:</span> <span class='c'></span>
<span class='n'>1106:</span> <span class='c'></span>
<span class='n'>1107:</span> <span class='c'></span>
<span class='n'>1108:</span> <span class='c'>//==============================================================================</span>
<span class='n'>1109:</span> <span class='c'>// checkOption  V1.2</span>
<span class='n'>1110:</span> <span class='c'>//</span>
<span class='n'>1111:</span> <span class='c'>// Routine checks whether option passed via argv[*pi] fits to the option in</span>
<span class='n'>1112:</span> <span class='c'>// option list pointed to by pOp.</span>
<span class='n'>1113:</span> <span class='c'>//</span>
<span class='n'>1114:</span> <span class='c'>// If the currently checked option *pOp fits to the currently examined command</span>
<span class='n'>1115:</span> <span class='c'>// line argument argv[*pi] and if it is an option with a parameter store the</span>
<span class='n'>1116:</span> <span class='c'>// value in the option structure and return 1.</span>
<span class='n'>1117:</span> <span class='c'>//</span>
<span class='n'>1118:</span> <span class='c'>// If the currently checked option *pOp fits to the currently examined command</span>
<span class='n'>1119:</span> <span class='c'>// line argument argv[*pi] and if it is an option without a parameter increment</span>
<span class='n'>1120:</span> <span class='c'>// the option value in the option structure by one and return 0.</span>
<span class='n'>1121:</span> <span class='c'>//</span>
<span class='n'>1122:</span> <span class='c'>// If the currently checked option *pOp doesn't fit to the currently examined</span>
<span class='n'>1123:</span> <span class='c'>// command line argument argv[*pi] return 0.</span>
<span class='n'>1124:</span> <span class='c'></span>
<span class='n'>1125:</span> <span class='e'>static int  checkOption (</span>
<span class='n'>1126:</span> <span class='c'>    const int           argc,    // No. of command line entries (from main())</span>
<span class='n'>1127:</span> <span class='c'>    const char   *const argv[],  // Command line entries  (from main())</span>
<span class='n'>1128:</span> <span class='c'>          int    *const pi,      // Ptr to current command line entry index</span>
<span class='n'>1129:</span> <span class='c'>    const OPTION *const pOp      // Ptr to current option from option list</span>
<span class='n'>1130:</span> <span class='c'>) {</span>
<span class='n'>1131:</span> <span class='p'>    if (pOp-&gt;fmt &amp;&amp; pOp-&gt;fmt[1] == 's') {</span>
<span class='n'>1132:</span> <span class='c'>        // Test whether one of the different possibilities for this option</span>
<span class='n'>1133:</span> <span class='c'>        // fits to the just read command line option.</span>
<span class='n'>1134:</span> <span class='c'>        // Check at first whether the first characters are equal to the short</span>
<span class='n'>1135:</span> <span class='c'>        // or long option name.</span>
<span class='n'>1136:</span> <span class='c'></span>
<span class='n'>1137:</span> <span class='c'>        int  len;</span>
<span class='n'>1138:</span> <span class='c'></span>
<span class='n'>1139:</span> <span class='u'>        if (    ( len=strlen(pOp-&gt;shOpt), ! strncmp(argv[*pi],pOp-&gt;shOpt,len) )</span>
<span class='n'>1140:</span> <span class='u'>             || ( len=strlen(pOp-&gt;lgOpt), ! strncmp(argv[*pi],pOp-&gt;lgOpt,len) )</span>
<span class='n'>1141:</span> <span class='c'>           ) {</span>
<span class='n'>1142:</span> <span class='c'>            // It is this short or long option: Now, is it of kind</span>
<span class='n'>1143:</span> <span class='c'>            // "-Opt=XY" or "-OptXY" or "-Opt XY" (in that order)</span>
<span class='n'>1144:</span> <span class='c'></span>
<span class='n'>1145:</span> <span class='u'>            switch (argv[*pi][len]) {</span>
<span class='n'>1146:</span> <span class='u'>                case '\0': if (++*pi==argc) {</span>
<span class='n'>1147:</span> <span class='u'>                               fprintf (stderr, "\n"LOGO": Missing option argument\n");</span>
<span class='n'>1148:</span> <span class='u'>                               info (stderr);</span>
<span class='n'>1149:</span> <span class='c'>                           }</span>
<span class='n'>1150:</span> <span class='u'>                           *(const char**)pOp-&gt;val = argv[*pi];</span>
<span class='n'>1151:</span> <span class='u'>                           break;</span>
<span class='n'>1152:</span> <span class='c'></span>
<span class='n'>1153:</span> <span class='u'>                case '=' : ++len;</span>
<span class='n'>1154:</span> <span class='u'>                           *(const char**)pOp-&gt;val = argv[*pi] + len;</span>
<span class='n'>1155:</span> <span class='u'>                           break;</span>
<span class='n'>1156:</span> <span class='c'></span>
<span class='n'>1157:</span> <span class='u'>                default  : *(const char**)pOp-&gt;val = argv[*pi] + len;</span>
<span class='n'>1158:</span> <span class='u'>                           break;</span>
<span class='n'>1159:</span> <span class='c'>            }</span>
<span class='n'>1160:</span> <span class='u'>            return 1;           // Signal: option found and parameter read</span>
<span class='n'>1161:</span> <span class='c'>        }</span>
<span class='n'>1162:</span> <span class='c'>    } else {</span>
<span class='n'>1163:</span> <span class='c'>        char  fmtStr[MAXOPT+5];</span>
<span class='n'>1164:</span> <span class='c'></span>
<span class='n'>1165:</span> <span class='c'>        // Test whether one of the different possibilities for this option</span>
<span class='n'>1166:</span> <span class='c'>        // fits to the just read command line option.</span>
<span class='n'>1167:</span> <span class='c'>        // If the short option were "shOpt" and the long option were "loOpt"</span>
<span class='n'>1168:</span> <span class='c'>        // and the option value were 10 then the possibilities checked here</span>
<span class='n'>1169:</span> <span class='c'>        // would be "-shOpt10", "--loOpt10", "-shOpt=10" and "--loOpt=10".</span>
<span class='n'>1170:</span> <span class='c'></span>
<span class='n'>1171:</span> <span class='e'>        if (    pOp-&gt;fmt</span>
<span class='n'>1172:</span> <span class='e'>             &amp;&amp; (   // Assemble sscanf format string to e.g. "shopt=%f" etc.</span>
<span class='n'>1173:</span> <span class='e'>                    sscanf( argv[*pi], strcat(strcat(strncpy(fmtStr,pOp-&gt;shOpt,MAXOPT),"="),pOp-&gt;fmt), pOp-&gt;val )==1</span>
<span class='n'>1174:</span> <span class='e'>                 || sscanf( argv[*pi], strcat(       strncpy(fmtStr,pOp-&gt;shOpt,MAXOPT)     ,pOp-&gt;fmt), pOp-&gt;val )==1</span>
<span class='n'>1175:</span> <span class='e'>                 || sscanf( argv[*pi], strcat(strcat(strncpy(fmtStr,pOp-&gt;lgOpt,MAXOPT),"="),pOp-&gt;fmt), pOp-&gt;val )==1</span>
<span class='n'>1176:</span> <span class='e'>                 || sscanf( argv[*pi], strcat(       strncpy(fmtStr,pOp-&gt;lgOpt,MAXOPT)     ,pOp-&gt;fmt), pOp-&gt;val )==1</span>
<span class='n'>1177:</span> <span class='c'>                )</span>
<span class='n'>1178:</span> <span class='c'>           ) {</span>
<span class='n'>1179:</span> <span class='c'></span>
<span class='n'>1180:</span> <span class='e'>            return 1;           // Signal: option found and parameter read</span>
<span class='n'>1181:</span> <span class='c'></span>
<span class='n'>1182:</span> <span class='c'>        }</span>
<span class='n'>1183:</span> <span class='c'>        // Check short option without parameter</span>
<span class='n'>1184:</span> <span class='e'>        else if ( ! strncmp(argv[*pi],pOp-&gt;shOpt,strlen(pOp-&gt;shOpt)) &amp;&amp; ! pOp-&gt;fmt) {</span>
<span class='n'>1185:</span> <span class='c'>            // Command line argument is a short option without parameter</span>
<span class='n'>1186:</span> <span class='c'></span>
<span class='n'>1187:</span> <span class='e'>            ++*(int*)pOp-&gt;val;  // Set TRUE, or count up if used more than once</span>
<span class='n'>1188:</span> <span class='c'></span>
<span class='n'>1189:</span> <span class='e'>            return -1;          // Signal: boolean short option found</span>
<span class='n'>1190:</span> <span class='c'></span>
<span class='n'>1191:</span> <span class='c'>        }</span>
<span class='n'>1192:</span> <span class='c'>        // Check short option with parameter or</span>
<span class='n'>1193:</span> <span class='c'>        // long option with or without parameter</span>
<span class='n'>1194:</span> <span class='e'>        else if (    ! strcmp(argv[*pi],pOp-&gt;shOpt)</span>
<span class='n'>1195:</span> <span class='e'>                  || ! strcmp(argv[*pi],pOp-&gt;lgOpt)) {</span>
<span class='n'>1196:</span> <span class='c'></span>
<span class='n'>1197:</span> <span class='c'>            // Check whether the option is without parameter</span>
<span class='n'>1198:</span> <span class='e'>            if ( ! pOp-&gt;fmt) {</span>
<span class='n'>1199:</span> <span class='c'>                // Command line argument is a long option without parameter</span>
<span class='n'>1200:</span> <span class='c'>                // (short option has already checked above)</span>
<span class='n'>1201:</span> <span class='e'>                ++*(int*)pOp-&gt;val;  // Set TRUE, or count up if used more than once</span>
<span class='n'>1202:</span> <span class='c'></span>
<span class='n'>1203:</span> <span class='e'>                return 1;           // Signal: boolean long option found</span>
<span class='n'>1204:</span> <span class='c'></span>
<span class='n'>1205:</span> <span class='c'>            // We found a "-shOpt" or "--loOpt". Now we look for the number:</span>
<span class='n'>1206:</span> <span class='e'>            } else if (++*pi==argc || sscanf(argv[*pi],pOp-&gt;fmt,pOp-&gt;val)!=1) {</span>
<span class='n'>1207:</span> <span class='e'>                fprintf (stderr, "\n"LOGO": Invalid option argument %s\n\n", argv[*pi]);</span>
<span class='n'>1208:</span> <span class='e'>                info (stderr);      // No number with the correct format found !</span>
<span class='n'>1209:</span> <span class='c'>            } else {</span>
<span class='n'>1210:</span> <span class='e'>                return 1;           // Signal: option found and parameter read</span>
<span class='n'>1211:</span> <span class='c'>            }</span>
<span class='n'>1212:</span> <span class='c'>        }</span>
<span class='n'>1213:</span> <span class='c'>    }</span>
<span class='n'>1214:</span> <span class='c'></span>
<span class='n'>1215:</span> <span class='c'>    // The current test option was not the one recently read from command line</span>
<span class='n'>1216:</span> <span class='e'>    return 0;</span>
<span class='n'>1217:</span> <span class='c'>}</span>
<span class='n'>1218:</span> <span class='c'></span>
<span class='n'>1219:</span> <span class='c'></span>
<span class='n'>1220:</span> <span class='c'></span>
<span class='n'>1221:</span> <span class='c'>//==============================================================================</span>
<span class='n'>1222:</span> <span class='c'>// info</span>
<span class='n'>1223:</span> <span class='c'>//</span>
<span class='n'>1224:</span> <span class='c'>// Print informative usage message to stream passed as argument</span>
<span class='n'>1225:</span> <span class='c'>//</span>
<span class='n'>1226:</span> <span class='c'></span>
<span class='n'>1227:</span> <span class='e'>static void  info (</span>
<span class='n'>1228:</span> <span class='c'>    FILE *const  file</span>
<span class='n'>1229:</span> <span class='c'>) {</span>
<span class='n'>1230:</span> <span class='e'>    if (file != stderr) {</span>
<span class='n'>1231:</span> <span class='e'>        fputs (LOGO": Generate code to compute an FFT or IFFT\n"</span>
<span class='n'>1232:</span> <span class='c'>               "Version: "VERSION"\n\n", file);</span>
<span class='n'>1233:</span> <span class='c'>    }</span>
<span class='n'>1234:</span> <span class='e'>    fputs (</span>
<span class='n'>1235:</span> <span class='c'>        "Usage: fftGen [option...]\n"</span>
<span class='n'>1236:</span> <span class='c'>        "Options:\n"</span>
<span class='n'>1237:</span> <span class='c'>        "Mandatory arguments to long options are mandatory for short options too.\n"</span>
<span class='n'>1238:</span> <span class='c'>        " -n, --points NUMBER   Number of points, must be a power of 2.\n"</span>
<span class='n'>1239:</span> <span class='c'>        " -i, --inverse         Generate code for inverse FFT.\n"</span>
<span class='n'>1240:</span> <span class='c'>        " -r, --real-in-opt     Optimize for real only input.\n"</span>
<span class='n'>1241:</span> <span class='c'>        " -o, --real-out-opt    Optimize for real only output.\n"</span>
<span class='n'>1242:</span> <span class='c'>        " -m, --symm-in-opt     Optimize for symmetry at input sequence.\n"</span>
<span class='n'>1243:</span> <span class='c'>        " -s, --symm-out-opt    Optimize for symmetry at output sequence.\n"</span>
<span class='n'>1244:</span> <span class='c'>        " -l, --license         Write a GPL 3 note at the beginning of the code.\n"</span>
<span class='n'>1245:</span> <span class='c'>        " -v, --verbose         Increase verbosity level.\n"</span>
<span class='n'>1246:</span> <span class='c'>        "                       Verbose output is directed to stderr.\n"</span>
<span class='n'>1247:</span> <span class='c'>        " -V, --version         Print version and exit.\n"</span>
<span class='n'>1248:</span> <span class='c'>        " -h, --help            Print this info.\n"</span>
<span class='n'>1249:</span> <span class='c'>        "Note that it is required to specify the number of data points by option -n\n"</span>
<span class='n'>1250:</span> <span class='c'>        "or --points.\n"</span>
<span class='n'>1251:</span> <span class='c'>        "Result is written to stdout\n", file);</span>
<span class='n'>1252:</span> <span class='c'></span>
<span class='n'>1253:</span> <span class='e'>    if (file == stderr)  exit (EXIT_FAILURE);</span>
<span class='n'>1254:</span> <span class='e'>    else                 exit (EXIT_SUCCESS);</span>
<span class='n'>1255:</span> <span class='c'>}</span>
</pre></body></html>
